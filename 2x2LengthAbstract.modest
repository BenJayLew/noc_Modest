option "dtmc";

//Top level varables
const int BUFFERLENGTH = 4;
const int NOCSIZE = 2;
const int INJECTIONRATENUMERATOR = 1;
const int INJECTIONRATEDENOMINATOR = 2;

const int clkLower = 100; 
const int clkUpper = 106;
int(clkLower..clkUpper) clk;
//transient int(0..1) clk;

action tick;

int totalFlitsDelivered = 0;

datatype node = {int(0..4) localLen, int(0..4) ewLen, int(0..4) nsLen, bool localPriority, bool nsPriority, bool ewLockedns, bool ewLockedlocal, bool localLockedns};

node r0, r1, r2, r3;

node[] noc;

// ------ Begin: properties ---------
property Pr1 = Pmax(<> (clk == clkUpper));
//property p1 = Pmax(<>[S(clk)<=(clkUpper-clkLower)] (totalFlitsDelivered >= 2));
// ------ End: properties ---------

process Clock(){	
	
	//tick{= clk = 1 =};
	//Clock()
	
	
	tick {= clk++ =};
	if (clk <= clkUpper) {
	   Clock()
	}
	else {
	   stop
	} 
	
}

process Top(){
	initialize();
	do{
		populate();
		arbiter(0);
		arbiter(1);
		arbiter(2);
		arbiter(3);
		
		tick;
		
		if(clk>=clkUpper){
			stop
		}
		else{
			tauoption "dtmc";

//Top level varables
const int BUFFERLENGTH = 4;
const int NOCSIZE = 2;
const int INJECTIONRATENUMERATOR = 1;
const int INJECTIONRATEDENOMINATOR = 2;

const int clkLower = 100; 
const int clkUpper = 105;
int(clkLower..clkUpper) clk;
//transient int(0..1) clk;

action tick;

int totalFlitsDelivered = 0;

datatype node = {int(0..4) localLen, int(0..4) ewLen, int(0..4) nsLen, bool localPriority, bool nsPriority, bool ewLockedns, bool ewLockedlocal, bool localLockedns};

node r0, r1, r2, r3;

node[] noc;

// ------ Begin: properties ---------
property Pr1 = Pmax(<> (clk == clkUpper));
//property p1 = Pmax(<>[S(clk)<=(clkUpper-clkLower)] (totalFlitsDelivered >= 2));
// ------ End: properties ---------

process Clock(){	
	
	//tick{= clk = 1 =};
	//Clock()
	
	
	tick {= clk++ =};
	if (clk <= clkUpper) {
	   Clock()
	}
	else {
	   stop
	} 
	
}

process Top(){
	initialize();
	do{
		populate();
		arbiter(0);
		arbiter(1);
		arbiter(2);
		arbiter(3);
		
		
		tick;
		
		if(clk>=clkUpper){
			stop
		}
		else{
			tau

		} 	
		
	}
}

process initialize(){
	{=
	noc = [r0, r1, r2, r3]
	=}
}

process populate() {

if((clk % INJECTIONRATEDENOMINATOR) < INJECTIONRATENUMERATOR){
		{=
		noc[0].localLen += localNotFull1(0),
		noc[1].localLen += localNotFull1(1),
		noc[2].localLen += localNotFull1(2),
		noc[3].localLen += localNotFull1(3)
		=}
	}
	else {tau}

}
process arbiter(int n){

	if (noc[n].ewLen == 0) {

		if (noc[n].localLockedns == true) {
			{= noc[n].localLockedns = ((localNotEmpty(n) && !nsNotFull(yDirection(n)))), noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n)))*(localNotEmpty1(n)), noc[n].nsLen -= (nsNotEmpty1(n)) =}
		}
		else {
			palt {
				:(1/3): {= noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n)))*(localNotEmpty1(n)), noc[n].nsLen -= (nsNotEmpty1(n))  =}
				:(2/3): {=  noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].nsLen -= (nsNotEmpty1(n)) =}
			}
		}

	}
	else if ((noc[n].localPriority == true) && (noc[n].nsPriority == true)) {

		if (noc[n].localLockedns == true) {

			palt {
			:(1/2): {= noc[n].localLockedns = false, noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n)))*(localNotEmpty1(n)), noc[n].nsLen -= (nsNotEmpty1(n)), noc[n].ewLockedns = true, noc[n].localPriority = false =}   // Local and EW both send to 2
			:(1/2): {= noc[n].localLockedns = false, noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= nsNotFull0(n), noc[n].ewLockedlocal = nsNotEmpty(n), noc[n].nsPriority = !nsNotEmpty(n), noc[n].nsLen -= (nsNotEmpty1(n)) =}    //Local sends to 2, and EW sends to 0
			}
		}

		

		else{

			palt {
			:(1/6): {= noc[n].ewLockedns = (localNotEmpty(n) && nsNotEmpty(yDirection(n))), noc[n].localPriority = (localNotEmpty(n) && !nsNotEmpty(yDirection(n))), noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n)))*(localNotEmpty1(n)), noc[n].nsLen -= (nsNotEmpty1(n)) =}							//Local and EW both send to 2
			:(1/6): {= noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= nsNotFull0(n), noc[n].ewLockedlocal = nsNotEmpty(n), noc[n].nsPriority = !nsNotEmpty(n), noc[n].nsLen -= (nsNotEmpty1(n)) =}					//Local Sends to 2, EW to 0
			


			:(1/3): {= noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].ewLockedlocal = nsNotEmpty(n), noc[n].nsPriority = !nsNotEmpty(n), noc[n].nsLen -= (nsNotEmpty1(n)) =}							//Local has a 1 or 3 and EW has a 0
			:(1/3): {= noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= (nsNotFull1(yDirection(n))), noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n))), noc[n].nsPriority = !nsNotEmpty(n), noc[n].nsLen -= (nsNotEmpty1(n)) =}  //Local has a 1 or 3 and EW has a 2

			}	

		}



	}

	else if ((noc[n].localPriority == false) && (noc[n].nsPriority == false)) {

			if (noc[n].ewLockedlocal) {

				palt {
					:(1/3):    {= noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= 1, noc[n].nsPriority = nsNotEmpty(n) =}  //Local sends NS and EW sends local
					:(2/3):    {=  noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= 1, noc[n].nsPriority = nsNotEmpty(n) =}  // Local Sens EW and EW sends local

				}

			}
			else if (noc[n].ewLockedns) {

				palt {
					:(1/3):    {= noc[n].localPriority =localNotEmpty(n), noc[n].localLockedns = noc[n].localPriority, noc[n].ewLen -= nsNotFull1(yDirection(n)), noc[yDirection(n)].nsLen += nsNotFull1(yDirection(n)), noc[n].nsLen -= (nsNotEmpty1(n)) =}  //Local sends NS and EW sends NS
					:(2/3):    {=  noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= nsNotFull1(yDirection(n)), noc[yDirection(n)].nsLen += nsNotFull1(yDirection(n)), noc[n].nsLen -= (nsNotEmpty1(n)) =}  //Local sends EW and EW sends NS

				}

			}
			else {

				palt{

				:(1/6): {= noc[n].localPriority = nsNotFull(yDirection(n)), noc[n].localLockedns = nsNotFull(yDirection(n)), noc[n].ewLen -= (nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n))), noc[n].nsLen -= (nsNotEmpty1(n)) =}							//Local and EW both send to 2
				:(1/6): {= noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= 1, noc[n].nsPriority = nsNotEmpty(n) =}					//Local Sends to 2, EW to 0
			


				:(1/3): {= noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].nsPriority = nsNotEmpty(n), noc[n].ewLen -= 1 =}							//Local has a 1 or 3 and EW has a 0
				:(1/3): {= noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= (nsNotFull1(yDirection(n))), noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n))), noc[n].nsLen -= (nsNotEmpty1(n)) =}  //Local has a 1 or 3 and EW has a 2
			}

			}

	}




	else if ((noc[n].localPriority == false) && (noc[n].nsPriority == true)) {

		
		 if (noc[n].ewLockedns) {

				palt {
					:(1/3):    {= noc[n].localPriority =localNotEmpty(n), noc[n].localLockedns = noc[n].localPriority, noc[n].ewLen -= nsNotFull1(yDirection(n)), noc[yDirection(n)].nsLen += nsNotFull1(yDirection(n)), noc[n].nsLen -= (nsNotEmpty1(n)), noc[n].nsPriority = nsNotEmpty(n) =}  //Local sends NS and EW sends NS
					:(2/3):    {=  noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= nsNotFull1(yDirection(n)), noc[yDirection(n)].nsLen += nsNotFull1(yDirection(n)), noc[n].nsLen -= (nsNotEmpty1(n)), noc[n].nsPriority = nsNotEmpty(n) =}  //Local sends EW and EW sends NS

				}

			}
			else {




				palt {
					:(1/6): {= noc[n].localPriority = nsNotFull(yDirection(n)), noc[n].localLockedns = true, noc[n].ewLen -= (nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n))), noc[n].nsLen -= (nsNotEmpty1(n)) =}							//Local and EW both send to 2
					:(1/6): {= noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= 1, noc[n].nsPriority = nsNotEmpty(n) =}					//Local Sends to 2, EW to 0
			


					:(1/3): {= noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].nsPriority = !nsNotEmpty(n), noc[n].ewLen -= nsNotEmpty0(n) =}							//Local has a 1 or 3 and EW has a 0
					:(1/3): {= noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= (nsNotFull1(yDirection(n))), noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n))), noc[n].nsLen -= (nsNotEmpty1(n)) =}  //Local has a 1 or 3 and EW has a 2


				}
			}



	}
	else {   //Localpriority == true && nsPriority == false

		
		 if (noc[n].ewLockedlocal) {

				palt {
					:(1/3):    {= noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= 1, noc[n].nsPriority = nsNotEmpty(n) =}  //Local sends NS and EW sends local
					:(2/3):    {=  noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= 1, noc[n].nsPriority = nsNotEmpty(n) =}  // Local Sens EW and EW sends local

				}

			}
			else {




				palt {
					:(1/6): {= noc[n].localPriority = !nsNotFull(yDirection(n)), noc[n].localLockedns = noc[n].localPriority, noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n))), noc[n].nsLen -= (nsNotEmpty1(n)) =}							//Local and EW both send to 2
					:(1/6): {= noc[n].localLen -= (localNotEmpty1(n))*(nsNotFull1(yDirection(n))),  noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= 1, noc[n].nsPriority = nsNotEmpty(n) =}					//Local Sends to 2, EW to 0
			


					:(1/3): {= noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].nsPriority = nsNotEmpty(n), noc[n].ewLen -= 1 =}							//Local has a 1 or 3 and EW has a 0
					:(1/3): {= noc[n].localLen -= (localNotEmpty1(n))*(ewNotFull1(xDirection(n))),  noc[xDirection(n)].ewLen += (ewNotFull1(xDirection(n)))*(localNotEmpty1(n)), noc[n].ewLen -= (nsNotFull1(yDirection(n))), noc[yDirection(n)].nsLen += (nsNotFull1(yDirection(n))), noc[n].nsLen -= (nsNotEmpty1(n)) =}  //Local has a 1 or 3 and EW has a 2


				}
			}



	}





}


function int(0..1) localNotEmpty1(int(0..4) n) =  (noc[n].localLen > 0) ? 1 : 0 ;     //ceil(noc[n].localLen/(noc[n].localLen+1));
function int(0..1) nsNotEmpty1(int(0..4) n) =    (noc[n].nsLen > 0) ? 1 : 0 ;        
function int(0..4) xDirection(int(0..1) n) =   (n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1);   
function int(0..4) yDirection(int(0..1) n) =   ((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2);  
function int(0..1) nsNotFull1(int(0..4) n) = (noc[n].nsLen < 4) ? 1 : 0;
function int(0..1) ewNotFull1(int(0..4) n) = (noc[n].ewLen < 4) ? 1 : 0;
function int(0..1) localNotFull1(int(0..4) n) = (noc[n].localLen < 4) ? 1 : 0;
function int(0..1) nsNotFull0(int(0..4) n) = ((noc[n].nsLen > 0 ) ? 0 : 1);
function bool nsNotFull(int(0..4) n) = ((noc[n].nsLen < 4) ? true: false);
function bool nsNotEmpty(int(0..4)n) = ((noc[n].nsLen > 0) ? true: false);
function bool localNotEmpty(int(0..4)n) = ((noc[n].localLen > 0) ? true: false);
function int(0..1) nsNotEmpty0(int(0..4) n) =    (noc[n].nsLen > 0) ? 0 : 1 ;


par{
::	Clock()
:: 	Top()
}

		} 	
		
	}
}

process initialize(){
	{=
	noc = [r0, r1, r2, r3]
	=}
}

process populate() {

if((clk % INJECTIONRATEDENOMINATOR) < INJECTIONRATENUMERATOR){
		{=
		noc[0].localLen += ((noc[0].localLen < 4) ? 1 : 0),
		noc[1].localLen += ((noc[1].localLen < 4) ? 1 : 0),
		noc[2].localLen += ((noc[2].localLen < 4) ? 1 : 0),
		noc[3].localLen += ((noc[3].localLen < 4) ? 1 : 0)
		=}
	}
	else {tau}

}
process arbiter(int n){

	if (noc[n].ewLen == 0) {

		if (noc[n].localLockedns == true) {
			{= noc[n].localLockedns = (((noc[n].localLen > 0) && (noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4)) ? false : true), noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}
		}
		else {
			palt {
				:(1/3): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0)  =}
				:(2/3): {=  noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}
			}
		}

	}
	else if ((noc[n].localPriority == true) && (noc[n].nsPriority == true)) {

		if (noc[n].localLockedns == true) {

			palt {
			:(1/2): {= noc[n].localLockedns = false, noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0), noc[n].ewLockedns = true, noc[n].localPriority = false =}   // Local and EW both send to 2
			:(1/2): {= noc[n].localLockedns = false, noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= ((noc[n].nsLen > 0 ) ? 0 : 1), noc[n].ewLockedlocal = ((noc[n].nsLen > 0 ) ? true : false), noc[n].nsPriority = ((noc[n].nsLen > 0) ? false: true), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}    //Local sends to 2, and EW sends to 0
			}
		}

		

		else{

			palt {
			:(1/6): {= noc[n].ewLockedns = (((noc[n].localLen > 0) && (noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4)) ? true: false), noc[n].localPriority = (((noc[n].localLen > 0) && (noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4)) ? false: true), noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}							//Local and EW both send to 2
			:(1/6): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= ((noc[n].nsLen > 0 ) ? 0 : 1), noc[n].ewLockedlocal = ((noc[n].nsLen > 0 ) ? true : false), noc[n].nsPriority = ((noc[n].nsLen > 0) ? false: true), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}					//Local Sends to 2, EW to 0
			


			:(1/3): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLockedlocal = ((noc[n].nsLen > 0 ) ? true : false), noc[n].nsPriority = ((noc[n].nsLen > 0) ? false: true), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}							//Local has a 1 or 3 and EW has a 0
			:(1/3): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1:0), noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1:0), noc[n].nsPriority = ((noc[n].nsLen > 0) ? false: true), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}  //Local has a 1 or 3 and EW has a 2

			}	

		}



	}

	else if ((noc[n].localPriority == false) && (noc[n].nsPriority == false)) {

			if (noc[n].ewLockedlocal) {

				palt {
					:(1/3):    {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= 1, noc[n].nsPriority = ((noc[n].nsLen > 0) ? true: false) =}  //Local sends NS and EW sends local
					:(2/3):    {=  noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= 1, noc[n].nsPriority = ((noc[n].nsLen > 0) ? true: false) =}  // Local Sens EW and EW sends local

				}

			}
			else if (noc[n].ewLockedns) {

				palt {
					:(1/3):    {= noc[n].localPriority =((noc[n].localLen > 0) ? true: false), noc[n].localLockedns = noc[n].localPriority, noc[n].ewLen -= ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1: 0), noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1: 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}  //Local sends NS and EW sends NS
					:(2/3):    {=  noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1: 0), noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1: 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}  //Local sends EW and EW sends NS

				}

			}
			else {

				palt{

				:(1/6): {= noc[n].localPriority = ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? true: false), noc[n].localLockedns = true, noc[n].ewLen -= ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}							//Local and EW both send to 2
				:(1/6): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= 1, noc[n].nsPriority = ((noc[n].nsLen > 0) ? true: false) =}					//Local Sends to 2, EW to 0
			


				:(1/3): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].nsPriority = ((noc[n].nsLen > 0) ? true: false), noc[n].ewLen -= 1 =}							//Local has a 1 or 3 and EW has a 0
				:(1/3): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1:0), noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1:0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}  //Local has a 1 or 3 and EW has a 2
			}

			}

	}




	else if ((noc[n].localPriority == false) && (noc[n].nsPriority == true)) {

		
		 if (noc[n].ewLockedns) {

				palt {
					:(1/3):    {= noc[n].localPriority =((noc[n].localLen > 0) ? true: false), noc[n].localLockedns = noc[n].localPriority, noc[n].ewLen -= ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1: 0), noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1: 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0), noc[n].nsPriority = ((noc[n].nsLen > 0) ? true: false) =}  //Local sends NS and EW sends NS
					:(2/3):    {=  noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1: 0), noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1: 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0), noc[n].nsPriority = ((noc[n].nsLen > 0) ? true: false) =}  //Local sends EW and EW sends NS

				}

			}
			else {




				palt {
					:(1/6): {= noc[n].localPriority = ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? true: false), noc[n].localLockedns = true, noc[n].ewLen -= ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}							//Local and EW both send to 2
					:(1/6): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= 1, noc[n].nsPriority = ((noc[n].nsLen > 0) ? true: false) =}					//Local Sends to 2, EW to 0
			


					:(1/3): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].nsPriority = ((noc[n].nsLen > 0) ? false: true), noc[n].ewLen -= ((noc[n].nsLen > 0) ? 0: 1) =}							//Local has a 1 or 3 and EW has a 0
					:(1/3): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1:0), noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1:0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}  //Local has a 1 or 3 and EW has a 2


				}
			}



	}
	else {   //Localpriority == true && nsPriority == false

		
		 if (noc[n].ewLockedlocal) {

				palt {
					:(1/3):    {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= 1, noc[n].nsPriority = ((noc[n].nsLen > 0) ? true: false) =}  //Local sends NS and EW sends local
					:(2/3):    {=  noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= 1, noc[n].nsPriority = ((noc[n].nsLen > 0) ? true: false) =}  // Local Sens EW and EW sends local

				}

			}
			else {




				palt {
					:(1/6): {= noc[n].localPriority = ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? false: true), noc[n].localLockedns = noc[n].localPriority, noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}							//Local and EW both send to 2
					:(1/6): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0),  noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= 1, noc[n].nsPriority = ((noc[n].nsLen > 0) ? true: false) =}					//Local Sends to 2, EW to 0
			


					:(1/3): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].nsPriority = ((noc[n].nsLen > 0) ? true: false), noc[n].ewLen -= 1 =}							//Local has a 1 or 3 and EW has a 0
					:(1/3): {= noc[n].localLen -= ((noc[n].localLen > 0 ) ? 1 : 0)*((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0),  noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen += ((noc[(n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1)].ewLen < 4) ? 1 : 0)*((noc[n].localLen > 0 ) ? 1 : 0), noc[n].ewLen -= ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1:0), noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen += ((noc[((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2)].nsLen < 4) ? 1:0), noc[n].nsLen -= ((noc[n].nsLen > 0 ) ? 1 : 0) =}  //Local has a 1 or 3 and EW has a 2


				}
			}



	}





}



par{
::	Clock()
:: 	Top()
}
