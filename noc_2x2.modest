/*
NoC router IDs
	0 - 1
	|   |
	2 - 3
*/

//Top level varables
const int BUFFERLENGTH = 4;
const int NOCSIZE = 2;
const int clkLower = 100; 
const int clkUpper = 102;
int(clkLower..clkUpper) clk;

int test, test1, test2;

int(0..3) startNode;

datatype intlist = { int(0.. ((NOCSIZE*NOCSIZE)-1)) hd, intlist option tl };

datatype buffer = {int(-1..3) dest, int(-1..4) val, int(0..4) id, bool serviced, int(0..4) priority, intlist option buff};		//Datatype for a buffer with the next buffer value, id of the buffer, whether the buffer was serviced last clock cycle or not, and the priority number of the buffer

datatype router = {int(0..3) unserviced, int(0..3) totalUnserviced, buffer[] bufferArray, buffer[] temp, int[]bufferID};	//Datatype for a router, includes router-specific variables and an array of buffers

router r0, r1, r2, r3;

router[] noc;

action tick;


// ------ Begin: properties ---------
property Pr1 = Pmax(<> (clk >= clkUpper));
// ------ End: properties ---------



// ------ Begin: function definitions ------- 
// Calculate length of list:
function int len(intlist option ls) = if ls == none then 0 else 1 + len(ls!.tl); // "!" accesses the value of a non-empty option (causes an error if the option is empty)

// Return the front of the queue, i.e., the last element of the given integer list. No changes are made to the list.
function int peekFront(intlist option ls) =
	 if ls == none then -1
	 else if ls!.tl == none then ls!.hd
	      else peekFront(ls!.tl);

//Remove the front of the queue, i.e., the last element of the given integer list. Return the modified list. 
function intlist option dequeue(intlist option ls) = 
	if ls == none then none
	else if	ls!.tl == none then none 
		 else some(intlist { hd: ls!.hd, tl: dequeue(ls!.tl) });	

//Insert a new entry n as the head of the list ls. If ls has already reached its capacity before adding n, return ls; otherwise, return modified ls with n as its head. 
function intlist option enqueue(int n, intlist option ls) = 
	if len(ls) == BUFFERLENGTH then ls
	else some(intlist { hd: n, tl: ls });		 

//Routing function	
function int route(int dest, int routerID) =
	if dest == -1 then -1/*no flit*/
	else if (dest % NOCSIZE) > (routerID % NOCSIZE) then 1/*east*/
	else if (dest % NOCSIZE) < (routerID % NOCSIZE) then 3/*west*/
	else if (dest / NOCSIZE) > (routerID / NOCSIZE) then 2/*south*/
	else if (dest / NOCSIZE) < (routerID / NOCSIZE) then 0/*north*/
	else 4/*local*/
	;
// ------ End: function definitions ------- 


// ------ Begin: process definitions ------
//---- Paralell Processes ----
process Clock(){	
	tick {= clk++ =};
	if (clk <= clkUpper) {
	   Clock()
	}
	else {
	   stop
	}   
}

process Top(){
	initialize();
	//{= noc[1].bufferArray[2].dest = 2 =};
	subPopulate(0);
	subPopulate(1);
	subPopulate(2);
	subPopulate(3);
	tick;
	initialRoute(0);
	initialRoute(1);
	initialRoute(2);
	initialRoute(3);
	do{
		Arbiter_corner(0);
		Arbiter_corner(1);
		Arbiter_corner(2);
		Arbiter_corner(3);
		tick
	}
}

process Populate(){
	tick;
	subPopulate(0);
	subPopulate(1);
	subPopulate(2);
	subPopulate(3)
}


//---- Sub processes ----
process Arbiter_corner(int routerID){
	//Service buffers-------------------------------------------------------------------------------------------------------
		
		//Buffer priority 0
		//<Service Buffer bufferArray[0]>--------------------------------------------------------
		{= 
		noc[routerID].bufferArray[0].serviced = true 
		=};
		
		//<Service buffer <bufferArray[1]> ------------------------------------------------------
		if((noc[routerID].bufferArray[1].val != -1) && (noc[routerID].bufferArray[1].val == noc[routerID].bufferArray[0].val)) {			//If buffer bufferArray[1] conflicts with bufferArray[0]
			{= 
			noc[routerID].bufferArray[1].serviced = false,
			noc[routerID].unserviced++ 		//Increment unserviced
			=}
		}
		else {
			{= 	//Service Buffer
			noc[routerID].bufferArray[1].serviced = true 
			=}
		};
		
		//<Service buffer bufferArray[2]> --------------------------------------------------------
		//If buffer bufferArray[2] conflicts with bufferArray[1] or bufferArray[0]
		if((noc[routerID].bufferArray[2].val != -1) && (noc[routerID].bufferArray[2].val == noc[routerID].bufferArray[1].val || noc[routerID].bufferArray[2].val == noc[routerID].bufferArray[0].val)){	
			{= 
			noc[routerID].bufferArray[2].serviced = false, 
			noc[routerID].unserviced++			//Increment unserviced
			=}
		}
		else {
			{= 		//Service Buffer
			noc[routerID].bufferArray[2].serviced = true 
			=}
		};
		
		
		//Increment optimal runs if there were no conflitcs -------------------------------------------------------------------
		{= 
			noc[routerID].totalUnserviced = noc[routerID].unserviced
		=};
		
		//Set priority values for the next run and update the value of the buffers----------------------------------------------
		setPriority(0, routerID);
		setPriority(1, routerID);
		setPriority(2, routerID);
		
		
		//Rewrite buffer array with new priority values-------------------------------------------------------------------------
		{= 
		noc[routerID].temp[noc[routerID].bufferArray[0].priority] = noc[routerID].bufferArray[0],
		noc[routerID].temp[noc[routerID].bufferArray[1].priority] = noc[routerID].bufferArray[1],
		noc[routerID].temp[noc[routerID].bufferArray[2].priority] = noc[routerID].bufferArray[2],
		
		noc[routerID].bufferID[noc[routerID].bufferArray[0].id] = noc[routerID].bufferArray[0].priority,
		noc[routerID].bufferID[noc[routerID].bufferArray[1].id] = noc[routerID].bufferArray[1].priority,
		noc[routerID].bufferID[noc[routerID].bufferArray[2].id] = noc[routerID].bufferArray[2].priority
		=};
		
		{= noc[routerID].bufferArray = noc[routerID].temp =}
}
/*
process Arbiter0(){
	initialize();
	
	//runtime loop
	do {
		//Service buffers-------------------------------------------------------------------------------------------------------
		
		//Buffer priority 0
		//<Service Buffer bufferArray[0]>--------------------------------------------------------
		{= 
		a0[0].serviced = true 
		=};
		
		//<Service buffer <bufferArray[1]> ------------------------------------------------------
		if((a0[1].val != -1) && (a0[1].val == a0[0].val)) {			//If buffer bufferArray[1] conflicts with bufferArray[0]
			{= 
			a0[1].serviced = false,
			unserviced0++ 		//Increment unserviced
			=}
		}
		else {
			{= 	//Service Buffer
			a0[1].serviced = true 
			=}
		};
		
		//<Service buffer bufferArray[2]> --------------------------------------------------------
		//If buffer bufferArray[2] conflicts with bufferArray[1] or bufferArray[0]
		if((a0[2].val != -1) && (a0[2].val == a0[1].val || a0[2].val == a0[0].val)){	
			{= 
			a0[2].serviced = false, 
			unserviced0++			//Increment unserviced
			=}
		}
		else {
			{= 		//Service Buffer
			a0[2].serviced = true 
			=}
		};
		
		
		//Increment optimal runs if there were no conflitcs -------------------------------------------------------------------
		{= 
			totalUnserviced0 = unserviced0
		=}
		
		//Set priority values for the next run and update the value of the buffers----------------------------------------------
		setPriority0(0, 0);
		setPriority0(1, 0);
		setPriority0(2, 0);
		
		
		//Rewrite buffer array with new priority values-------------------------------------------------------------------------
		{= 
		temp0[a0[0].priority] = a0[0],
		temp0[a0[1].priority] = a0[1],
		temp0[a0[2].priority] = a0[2],
		
		bufferID0[a0[0].id] = a0[0].priority,
		bufferID0[a0[1].id] = a0[1].priority,
		bufferID0[a0[2].id] = a0[2].priority
		=};
		
		tick {= a0 = temp0 =};
		
		if (clk >= clkUpper) {
			stop
		}
		else {
			tau
		}
	}
}


process Arbiter1(){
	
	//runtime loop
	do {
		//Service buffers-------------------------------------------------------------------------------------------------------
		
		//Buffer priority 0
		//<Service Buffer bufferArray[0]>--------------------------------------------------------
		{= 
		a1[0].serviced = true 
		=};
		
		//<Service buffer <bufferArray[1]> ------------------------------------------------------
		if((a1[1].val != -1) && (a1[1].val == a1[0].val)) {			//If buffer bufferArray[1] conflicts with bufferArray[0]
			{= 
			a1[1].serviced = false,
			unserviced1++ 		//Increment unserviced
			=}
		}
		else {
			{= 	//Service Buffer
			a1[1].serviced = true 
			=}
		};
		
		//<Service buffer bufferArray[2]> --------------------------------------------------------
		//If buffer bufferArray[2] conflicts with bufferArray[1] or bufferArray[0]
		if((a1[2].val != -1) && (a1[2].val == a1[1].val || a1[2].val == a1[0].val)){	
			{= 
			a1[2].serviced = false, 
			unserviced1++			//Increment unserviced
			=}
		}
		else {
			{= 		//Service Buffer
			a1[2].serviced = true 
			=}
		};
		
		
		//Increment optimal runs if there were no conflitcs -------------------------------------------------------------------
		{= 
			totalUnserviced1 = unserviced1
		=}
		
		//Set priority values for the next run and update the value of the buffers----------------------------------------------
		setPriority1(0, 1);
		setPriority1(1, 1);
		setPriority1(2, 1);
		
		
		//Rewrite buffer array with new priority values-------------------------------------------------------------------------
		{= 
		temp1[a1[0].priority] = a1[0],
		temp1[a1[1].priority] = a1[1],
		temp1[a1[2].priority] = a1[2],
		
		bufferID1[a1[0].id] = a1[0].priority,
		bufferID1[a1[1].id] = a1[1].priority,
		bufferID1[a1[2].id] = a1[2].priority
		=};
		
		tick {= a1 = temp1 =};
		
		if (clk >= clkUpper) {
			stop
		}
		else {
			tau
		}
	}
}
*/

	
//initialize values --------------------------------------------------------------------------------------------------------------------------------------------
process initialize(){
	{= 
	noc = [r0, r1, r2, r3]
	=};
	
	initialize_node_nw(0);
	initialize_node_ne(1);
	initialize_node_sw(2);
	initialize_node_se(3)
}

process initialize_node_nw(int routerID){
	buffer east, south, local;
	{=
	noc[routerID].bufferArray = [east, south, local],
	noc[routerID].temp = [east, south, local],
	
	noc[routerID].bufferID = [-1, 0, 1, -1, 2],
	
	noc[routerID].bufferArray[0].id = 1, 
	noc[routerID].bufferArray[1].id = 2, 
	noc[routerID].bufferArray[2].id = 4,
	
	noc[routerID].bufferArray[0].dest = -1,
	noc[routerID].bufferArray[1].dest = -1,
	noc[routerID].bufferArray[2].dest = -1,
	
	noc[routerID].unserviced = 0
	
	=}
}

process initialize_node_ne(int routerID){
	buffer south, west, local;
	{=
	noc[routerID].bufferArray = [south, west, local],
	noc[routerID].temp = [south, west, local], 
	
	noc[routerID].bufferID = [-1, -1, 0, 1, 2],
	
	noc[routerID].bufferArray[0].id = 2, 
	noc[routerID].bufferArray[1].id = 3, 
	noc[routerID].bufferArray[2].id = 4,
	
	noc[routerID].bufferArray[0].dest = -1,
	noc[routerID].bufferArray[1].dest = -1,
	noc[routerID].bufferArray[2].dest = -1,
	
	noc[routerID].unserviced = 0
	=}
}

process initialize_node_sw(int routerID){
	buffer north, east, local;
	{=
	noc[routerID].bufferArray = [north, east, local],
	noc[routerID].temp = [north, east, local], 
	
	noc[routerID].bufferID = [0, 1, -1, -1, 2],
	
	noc[routerID].bufferArray[0].id = 0, 
	noc[routerID].bufferArray[1].id = 1, 
	noc[routerID].bufferArray[2].id = 4,
	
	noc[routerID].bufferArray[0].dest = -1,
	noc[routerID].bufferArray[1].dest = -1,
	noc[routerID].bufferArray[2].dest = -1,
	
	noc[routerID].unserviced = 0
	=}
}

process initialize_node_se(int routerID){
	buffer north, west, local;
	{=
	noc[routerID].bufferArray = [north, west, local],
	noc[routerID].temp = [north, west, local], 
	
	noc[routerID].bufferID = [0, -1, -1, 1, 2],
	
	noc[routerID].bufferArray[0].id = 0, 
	noc[routerID].bufferArray[1].id = 3, 
	noc[routerID].bufferArray[2].id = 4,
	
	noc[routerID].bufferArray[0].dest = -1,
	noc[routerID].bufferArray[1].dest = -1,
	noc[routerID].bufferArray[2].dest = -1,
	
	noc[routerID].unserviced = 0
	=}
	
}


process initialRoute(int routerID){
	
	{=
	noc[routerID].bufferArray[0].val = route(noc[routerID].bufferArray[0].dest, routerID),
	noc[routerID].bufferArray[1].val = route(noc[routerID].bufferArray[1].dest, routerID),
	noc[routerID].bufferArray[2].val = route(noc[routerID].bufferArray[2].dest, routerID)
	=}
}


//Sets the new priority value of buffer bufferArray[i] and updates the value if the buffer was serviced ------------------------------------------------------------------
process setPriority(int i, int routerID){
	if (noc[routerID].bufferArray[i].serviced == true){
		if(noc[routerID].bufferArray[i].val == -1){ tau }
		else if(noc[routerID].bufferArray[i].val == 4){
			tau		//flit delivered
		}
		else if(noc[routerID].bufferArray[i].val == 0){
			/*
			{=
			noc[routerID + (((-(noc[routerID].bufferArray[i].val) + 2) * (noc[routerID].bufferArray[i].val % 2)) + (NOCSIZE * (noc[routerID].bufferArray[i].val - 1) * ((noc[routerID].bufferArray[i].val + 1) % 2)))].bufferArray[noc[routerID].bufferID[(noc[routerID].bufferArray[i].val + 2) % 4]].buff = enqueue(noc[routerID].bufferArray[i].dest, noc[routerID + (((-(noc[routerID].bufferArray[i].val) + 2) * (noc[routerID].bufferArray[i].val % 2)) + (NOCSIZE * (noc[routerID].bufferArray[i].val - 1) * ((noc[routerID].bufferArray[i].val + 1) % 2)))].bufferArray[noc[routerID].bufferID[(noc[routerID].bufferArray[i].val + 2) % 4]].buff) 
				//transfer destination value to next router
			=}
			*/
			
			{=
			noc[routerID - NOCSIZE].bufferArray[noc[routerID - NOCSIZE].bufferID[2]].buff = enqueue(noc[routerID].bufferArray[i].dest, noc[routerID - NOCSIZE].bufferArray[noc[routerID - NOCSIZE].bufferID[2]].buff)
			=}
		}
		else if(noc[routerID].bufferArray[i].val == 1){
			{=
			noc[routerID + 1].bufferArray[noc[routerID + 1].bufferID[3]].buff = enqueue(noc[routerID].bufferArray[i].dest, noc[routerID + 1].bufferArray[noc[routerID + 1].bufferID[3]].buff)
			=}
		}
		else if(noc[routerID].bufferArray[i].val == 2){
			{=
			noc[routerID + NOCSIZE].bufferArray[noc[routerID + NOCSIZE].bufferID[0]].buff = enqueue(noc[routerID].bufferArray[i].dest, noc[routerID + NOCSIZE].bufferArray[noc[routerID + NOCSIZE].bufferID[0]].buff)
			=}
		}
		else if(noc[routerID].bufferArray[i].val == 3){
			{=
			noc[routerID - 1].bufferArray[noc[routerID - 1].bufferID[1]].buff = enqueue(noc[routerID].bufferArray[i].dest, noc[routerID - 1].bufferArray[noc[routerID - 1].bufferID[1]].buff)
			=}
		}
		else {tau};
		
		{= 
		noc[routerID].bufferArray[i].dest = peekFront(noc[routerID].bufferArray[i].buff),
		noc[routerID].bufferArray[i].val = route(peekFront(noc[routerID].bufferArray[i].buff), routerID),		//Update value from buffer
		noc[routerID].bufferArray[i].buff = dequeue(noc[routerID].bufferArray[i].buff),			//deque buffer
		noc[routerID].bufferArray[i].priority = i + noc[routerID].unserviced 				//Set new priority
		=}
	}
	else {
		{= 
		noc[routerID].bufferArray[i].priority = noc[routerID].totalUnserviced - noc[routerID].unserviced,		//Set new priority
		noc[routerID].unserviced-- 						//decrement unserviced
		=}
	}
}


process subPopulate(int routerID){
	{= noc[routerID].bufferArray[noc[routerID].bufferID[4]].buff = enqueue(DiscreteUniform(0, 3), noc[routerID].bufferArray[noc[routerID].bufferID[4]].buff) =}
}
// ------- End: process definitions -------

par{
::	Clock()
:: 	Top()
::	Populate()
}