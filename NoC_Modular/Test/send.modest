option "dtmc";

// ------------------------------------------------------- Datatypes -------------------------------------------------------

datatype buffer = {int(0..NOC_MAX_ID) hd, buffer option tl};
datatype channel = {buffer option buffer, int(0..4) priority};
datatype router = {channel channel_local, channel channel_north, channel channel_west, channel channel_east, channel channel_south,
	int(-1..NOC_MAX_ID) id_north, int(-1..NOC_MAX_ID) id_west, int(-1..NOC_MAX_ID) id_east, int(-1..NOC_MAX_ID) id_south};



// --------------------------------------------------- Top level varables --------------------------------------------------

// #MODULARIZE by setting NOC_MAX_ID to 1 less than the total number of routers and allocating spaces for more routers
const int NOC_MAX_ID = 1;
router[] noc = [router {}, router {}];

const int BUFFER_LENGTH = 3;

const int NORTH = 0;
const int WEST = 1;
const int EAST = 2;
const int SOUTH = 3;



// ------------------------------------------------------- Functions -------------------------------------------------------

// Calculate length of list
function int len(buffer option ls) = if ls == none then 0 else 1 + len(ls!.tl);

// Tell if the buffer is full
function bool isBufferFull(int id, int direction) =
	// Buffer should never have more than BUFFER_LENGTH, but just in case
	if (direction == NORTH) then len(noc[id].channel_north.buffer) >= BUFFER_LENGTH
	else if (direction == WEST) then len(noc[id].channel_west.buffer) >= BUFFER_LENGTH
	else if (direction == EAST) then len(noc[id].channel_west.buffer) >= BUFFER_LENGTH
	else if (direction == SOUTH) then len(noc[id].channel_south.buffer) >= BUFFER_LENGTH
	else false;

// Return the front of the queue
function int peekFront(buffer option ls) =
	 if ls == none then -1
	 else if ls!.tl == none then ls!.hd
	      else peekFront(ls!.tl);

// Add a flit to the buffer
function buffer option enqueue(int n, buffer option ls) = 
	if len(ls) == BUFFER_LENGTH then ls
	else some(buffer { 
		hd: n,
		tl: ls 
	});

// Remove a flit from the buffer
function buffer option dequeue(buffer option ls) = 
	if ls == none then none
	else if	ls!.tl == none then none 
	else some(buffer {
		hd: ls!.hd,
		tl: dequeue(ls!.tl)
	});



// ------------------------------------------------------- Processes -------------------------------------------------------

// Send flit to northern router
process SendNorth(int id){
	// We want to chech the south buffer of the NoC we are headed into, to see if it is full
	if(!isBufferFull(noc[id].id_north, SOUTH)){
		{=
			// Add flit to next buffer
			noc[noc[id].id_north].channel_south.buffer = enqueue(peekFront(noc[id].channel_north.buffer), noc[noc[id].id_north].channel_south.buffer),
			// Remove it from this buffer
			noc[id].channel_north.buffer = dequeue(noc[id].channel_north.buffer)
		=}
	}
	else{
		tau
	}
}



// Process for Arbiter 1
process Arbiter(int id, int id_north, int id_west, int id_east, int id_south){
	// Initialize
	channel temp;
	{=
		temp = channel {priority: 0},
		noc[id] = router {channel_local: temp, channel_north: temp, channel_west: temp, channel_east: temp, channel_south: temp,
			id_north: id_north, id_west: id_west, id_east: id_east, id_south: id_south},

		// TEST: Create the router we're sending to
		noc[1] = router {channel_local: temp, channel_north: temp, channel_west: temp, channel_east: temp, channel_south: temp,
			id_north: -1, id_west: -1, id_east: -1, id_south: 0},

		// TEST: Create a flit with destination of north router id
		noc[id].channel_local.buffer = enqueue(1, none)
	=};

	// Run
	do{
		// Send the flit
		SendNorth(id);

		// End program
		stop
	}
}



// ------------------------------------------------------- Execution -------------------------------------------------------

Arbiter(0, 1, -1, -1, -1)
