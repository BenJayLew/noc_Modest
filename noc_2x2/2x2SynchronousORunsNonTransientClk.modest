option "dtmc";

//Top level varables
const int BUFFERLENGTH = 4;
const int NOCSIZE = 2;
const int INJECTIONRATENUMERATOR = 1;
const int INJECTIONRATEDENOMINATOR = 2;

const int clkLower = 100; 
const int clkUpper = 115;
int(clkLower..clkUpper) clk;
//transient int(0..1) clk;


action tick;


/*transient int //totalFlitsDelivered0 = 0;
transient int //totalFlitsDelivered1 = 0;
transient int //totalFlitsDelivered2 = 0;
transient int //totalFlitsDelivered3 = 0;
int //totalFlitsDelivered;*/



datatype node = {int(0..4) localLen, int(0..4) ewLen, int(0..4) nsLen, bool localPriority, bool nsPriority, bool ewLockedns, bool ewLockedlocal, bool localLockedns, bool localLockedew};

transient int (0..1) optimalRuns0 = 0;
transient int (0..1) optimalRuns1 = 0;
transient int (0..1) optimalRuns2 = 0;
transient int (0..1) optimalRuns3 = 0;
int optimalRuns;


transient int(0..1) nsShouldDec0 = 0; 
transient int(0..1) nsShouldDec1 = 0; 
transient int(0..1) nsShouldDec2 = 0; 
transient int(0..1) nsShouldDec3 = 0; 

transient int(0..1) ewShouldDec0 = 0; 
transient int(0..1) ewShouldDec1 = 0; 
transient int(0..1) ewShouldDec2 = 0; 
transient int(0..1) ewShouldDec3 = 0; 

transient int (0..1) nsShouldInc0 = 0;
transient int (0..1) nsShouldInc1 = 0; 
transient int (0..1) nsShouldInc2 = 0; 
transient int (0..1) nsShouldInc3 = 0; 

transient int (0..1) ewShouldInc0 = 0;
transient int (0..1) ewShouldInc1 = 0;
transient int (0..1) ewShouldInc2 = 0;
transient int (0..1) ewShouldInc3 = 0;

//node r0, r1, r2, r3;

node[] noc = [node {localLen:0}, node {localLen: 0}, node {localLen:0}, node {localLen:0}];

//transient int(0..1) localNotEmptyOne = 0;


function int(0..1) localNotEmpty1(int(0..4) n) =  /*localNotEmptyOne;*/ (noc[n].localLen > 0) ? 1 : 0 ;     //ceil(noc[n].localLen/(noc[n].localLen+1));
//function int(0..1) localNotEmpty1(int(0..4) n) = localNotEmptyOne;


function int(0..1) localNotEmpty0(int(0..4) n) =  (noc[n].localLen > 0) ? 0 : 1 ; 
function int(0..1) nsNotEmpty1(int(0..4) n) =    (noc[n].nsLen > 0) ? 1 : 0 ;        
//function int(0..4) xDirection(int(0..1) n) =   (n % 2)*(n - 1) + (-(n % 2) + 1)*(n + 1);   
//function int(0..4) yDirection(int(0..1) n) =   ((int)(n/2))*(n - 2) + (-((int)(n/2)) + 1)*(n + 2);  
function int(0..1) nsNotFull1(int(0..4) n) = (noc[n].nsLen < 4) ? 1 : 0;
function int(0..1) ewNotFull1(int(0..4) n) = (noc[n].ewLen < 4) ? 1 : 0;
function int(0..1) localNotFull1(int(0..4) n) = (noc[n].localLen < 4) ? 1 : 0;
function int(0..1) nsNotFull0(int(0..4) n) = ((noc[n].nsLen < 4 ) ? 0 : 1);
function bool nsNotFull(int(0..4) n) = ((noc[n].nsLen < 4));
function bool ewNotFull(int(0..4) n) = ((noc[n].ewLen < 4));
function bool nsNotEmpty(int(0..4)n) = ((noc[n].nsLen > 0));
function bool localNotEmpty(int(0..4)n) = ((noc[n].localLen > 0));
function bool localNotFull(int(0..4)n) = ((noc[n].localLen < 4));
function int(0..1) nsNotEmpty0(int(0..4) n) =    (noc[n].nsLen > 0)? 0 : 1;




// ------ Begin: properties ---------
property Pr1 = Pmax(<> (clk >= clkUpper) );
property p1 = Pmax(<>((optimalRuns) >= 1));
//property p2 = Pmax(<>[S(clk)<=(clkUpper-clkLower)] (optimalRuns == 1));
//property p3 = Pmax(<>[S(clk)<=(clkUpper-clkLower)] ((optimalRuns0 == 1) | (optimalRuns1==1) | (optimalRuns2==1) | (optimalRuns3==1)));
// ------ End: properties ---------


process Top(){
	//initialize();
	//begin;
	//do{

		

		populate();

		if (clkUpper-clk <= 0) {
		 stop
		}
		else {
		Top()
		}
		
			
		
	//}
}

process Arbiter0() {
	//begin;
	//do{

		arbiter0();

		if (clkUpper-clk <= 0) {
		 stop
		}
		else {
		Arbiter0()
		}
		

//	}


}

process Arbiter1() {
	//begin;
	//do{

		arbiter1();

		if (clkUpper-clk <= 0) {
		 stop
		}
		else {
		Arbiter1()
		}
		

//	}


}

process Arbiter2() {
	//begin;
	//do{

		arbiter2();
		if (clkUpper-clk <= 0) {
		 stop
		}
		else {
		Arbiter2()
		}
		

	//}


}

process Arbiter3() {
	//begin;
	//do{

		arbiter3();
		if (clkUpper-clk <= 0) {
		 stop
		}
		else {
		Arbiter3()
		}
		

//	}


}

/*process initialize(){
	{=
	noc = [node r0, node r1, node r2, node r3]
	=}
}*/

process populate() {

	if(clk%2 == 0) {

		 tick {= 


		-1: noc[0].localLen += localNotFull1(0),		//Adds a flit to the local buffer of each NoC, if they are not already full
		-1: noc[1].localLen += localNotFull1(1),
		-1: noc[2].localLen += localNotFull1(2),
		-1: noc[3].localLen += localNotFull1(3),

		1: noc[0].nsLen += (nsShouldInc0 - nsShouldDec0),
		1: noc[1].nsLen += (nsShouldInc1 - nsShouldDec1),
		1: noc[2].nsLen += (nsShouldInc2 - nsShouldDec2),
		1: noc[3].nsLen += (nsShouldInc3 - nsShouldDec3),

		1: noc[0].ewLen += (ewShouldInc0 - ewShouldDec0),
		1: noc[1].ewLen += (ewShouldInc1 - ewShouldDec1),
		1: noc[2].ewLen += (ewShouldInc2 - ewShouldDec2),
		1: noc[3].ewLen += (ewShouldInc3 - ewShouldDec3),

		1: optimalRuns += (optimalRuns0 + optimalRuns1 + optimalRuns2 + optimalRuns3),

		1: clk++

		=}

	}
	else {

			tick {=

		1: noc[0].nsLen += (nsShouldInc0 - nsShouldDec0),
		1: noc[1].nsLen += (nsShouldInc1 - nsShouldDec1),
		1: noc[2].nsLen += (nsShouldInc2 - nsShouldDec2),
		1: noc[3].nsLen += (nsShouldInc3 - nsShouldDec3),

		1: noc[0].ewLen += (ewShouldInc0 - ewShouldDec0),
		1: noc[1].ewLen += (ewShouldInc1 - ewShouldDec1),
		1: noc[2].ewLen += (ewShouldInc2 - ewShouldDec2),
		1: noc[3].ewLen += (ewShouldInc3 - ewShouldDec3),

		1: optimalRuns += (optimalRuns0 + optimalRuns1 + optimalRuns2 + optimalRuns3),

		1: clk++

		=}

	}



}


process arbiter0(){

	//tick {= localNotEmptyOne = (noc[0].localLen > 0) ? 1 : 0 =};

	if (noc[0].ewLen == 0) {		//If the EW buffer of the NoC is empty

		if (noc[0].localLockedns == true) {		//If the local buffer is locked sending NS

			tick {= noc[0].localLockedns = !nsNotFull(2),  //Sets the priority to false if it was able to send to the ns buffer of the NoC in the y direction
				noc[0].localPriority = !nsNotFull(2) || noc[0].localPriority,		//Local gets priority if it is unable to send
				noc[0].localLen -= nsNotFull1(2),     //Local sends a flit ns if the receiving buffer is not full
				nsShouldInc2 = (nsNotFull1(2)),  //The ns direction receives the flit if it is not already full
				nsShouldDec0 = (nsNotEmpty1(0))						//The ns buffer sends a flit to local if it is not empty
				//totalFlitsDelivered0 += nsNotEmpty1(0)
			=}

		}

		else if (noc[0].localLockedew) {

			tick {=  		noc[0].localLockedew = !ewNotFull(1), // Local is locked it if has a flit and is unable to send it
							noc[0].localPriority = !ewNotFull(1) || noc[0].localPriority,  // Local gets priority under the same conditions		
							noc[0].localLen -= (ewNotFull1(1)),  //Local sends a flit to the ew direction if it is not empty and the receiving buffer is not full
							ewShouldInc1 = (ewNotFull1(1)), //The ew direction receives it under the same conditions
							nsShouldDec0 = (nsNotEmpty1(0)) //The ns buffer sends a flit to local if it is not empty
							//totalFlitsDelivered0 += nsNotEmpty1(0)	
							
			=}


		} 

		else {
			tick palt {
				//Local sends in the NS direction
				:(1/3):  {=  noc[0].localLockedns = localNotEmpty(0) && !nsNotFull(2), // Local is locked it if has a flit and is unable to send it
							noc[0].localPriority = (localNotEmpty(0) && !nsNotFull(2)) || noc[0].localPriority,  // Local gets priority under the same conditions
							noc[0].localLen -= (localNotEmpty1(0))*(nsNotFull1(2)),  //Local sends a flit to the ns direction if it is not empty and the receiving buffer is not full
					   		nsShouldInc2 = (nsNotFull1(2))*(localNotEmpty1(0)), //The ns direction receives the flit under the same conditions
							nsShouldDec0 = (nsNotEmpty1(0))   //The ns buffer sends a flit to local if it is not empty	
							//totalFlitsDelivered0 += nsNotEmpty1(0)
						=}
				//Local sends to the ew direction
				:(2/3): {=  noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1), // Local is locked it if has a flit and is unable to send it
							noc[0].localPriority = (localNotEmpty(0) && !ewNotFull(1)) || noc[0].localPriority,  // Local gets priority under the same conditions
							noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  //Local sends a flit to the ew direction if it is not empty and the receiving buffer is not full
							ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), //The ew direction receives it under the same conditions
							nsShouldDec0 = (nsNotEmpty1(0)) //The ns buffer sends a flit to local if it is not empty
							//totalFlitsDelivered0 += nsNotEmpty1(0)
							
						=}
			}
		}

	}
	else if ((noc[0].localPriority == true) && (noc[0].nsPriority == true)) {

		if (noc[0].localLockedns == true) {

			if (noc[0].ewLockedns) {

				tick {= noc[0].localLockedns = !nsNotFull(2), 	//Local stays locked if it is unable to send
					noc[0].localPriority = !nsNotFull(2),
						noc[0].localLen -= nsNotFull1(2),  //Local sends if the ns direction is not already full
						nsShouldInc2 = nsNotFull1(2), //The ns direction receives under the same conditions
						noc[0].nsPriority = false,
						noc[0].ewLockedns = true, 
						nsShouldDec0 = (nsNotEmpty1(0))   //The ns buffer sends a flit to local if it is not empty 
						//totalFlitsDelivered0 += nsNotEmpty1(0)
				=}

			}

			else {
			tick palt {
			// Local and EW both send ns	
			:(1/2):  {= noc[0].localLockedns = !nsNotFull(2), 	//Local stays locked if it is unable to send
						noc[0].localLen -= nsNotFull1(2),  //Local sends if the ns direction is not already full
						nsShouldInc2 = nsNotFull1(2), //The ns direction receives under the same conditions
						nsShouldDec0 = (nsNotEmpty1(0)),   //The ns buffer sends a flit to local if it is not empty
						noc[0].nsPriority = false,
						//totalFlitsDelivered0 += nsNotEmpty1(0),
						noc[0].ewLockedns = true, 			//The Ew buffer is locked to send in the ns direction
						noc[0].localPriority = !nsNotFull(2) //Local remains in priority if it did not send
					=}  
			 
			 //Local sends ns, and EW sends to to local
			:(1/2):  {= noc[0].localLockedns =  !nsNotFull(2),  //Local stays locked if it is unable to send
						noc[0].localPriority = !(nsNotFull(2) && nsNotEmpty(0)), //Local only loses priority if it sends and ew doesn't
						noc[0].localLen -= (nsNotFull1(2)),  //Local sends ns if it isn't empty and ns isn't full
						nsShouldInc2 = (nsNotFull1(2)), //Ns receives under the same conditions
						ewShouldDec0 = nsNotEmpty0(0), 	//Ew sends if the ns buffer is empty
						noc[0].ewLockedlocal = nsNotEmpty(0), 	//Local is locked if the ns buffer is not empty
						noc[0].nsPriority = !nsNotEmpty(0),     //NS loses priority if it sends
						nsShouldDec0 = (nsNotEmpty1(0)) 		//Ns sends local if it isn't empty
						//totalFlitsDelivered0 += nsNotEmpty1(0)
					=}    
			}
		}

		}

		else if (noc[0].localLockedew) {

			if(noc[0].ewLockedns) {	

				//Local has a 1 or 3 and EW has a 2
				tick {= noc[0].localLockedew = !ewNotFull(1), //Local is locked in the ew direction if it is unable to send
							noc[0].localPriority = !(!ewNotFull(1) && nsNotFull(2)), //Local remains in priority under the same conditions
							noc[0].localLen -= (ewNotFull1(1)),  //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc1 = (ewNotFull1(1)), //The ew direction recieves under the same conditions
							ewShouldDec0 = (nsNotFull1(2)),  // Ew sends if the ns direction is not full
							noc[0].ewLockedns = !nsNotFull(2), // Ew is locked to ns if it is unable to send
							nsShouldInc2 = (nsNotFull1(2)), //The ns direction receives if it is not full
							noc[0].nsPriority = nsNotFull(2),  //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec0 = (nsNotEmpty1(0)), // Ns sends if it is not empty
							//totalFlitsDelivered0 += nsNotEmpty1(0),
							optimalRuns0 += ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)

				=} 


			}

			else {

				tick palt { 

				//Local has a 1 or 3 and EW has a 0	
				:(1/2):  {= noc[0].localLockedew = !ewNotFull(1), //Local is locked in the ew direction if it is unable to send
							noc[0].localPriority = !(ewNotFull(1) && nsNotEmpty(0)), //Local remains in priority under the same conditions
							noc[0].localLen -= (ewNotFull1(1)),  //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc1 = (ewNotFull1(1)), //The ew direction receives under the same conditions
							noc[0].ewLockedlocal = nsNotEmpty(0), //The ew buffer is locked into the local direction if the ns buffer is not empty
							noc[0].nsPriority = !nsNotEmpty(0),  //The ns buffer remains in priority if it is empty
							nsShouldDec0 = (nsNotEmpty1(0)),	//Ns sneds if it is not empty
							ewShouldDec0 = nsNotEmpty0(0)		//Ew sends if 
							//totalFlitsDelivered0 += 1
				=}	

				//Local has a 1 or 3 and EW has a 2
				:(1/2):  {= noc[0].localLockedew = !ewNotFull(1), //Local is locked in the ew direction if it is unable to send
							noc[0].localPriority = !(!ewNotFull(1) && nsNotFull(2)), //Local remains in priority under the same conditions
							noc[0].localLen -= (ewNotFull1(1)),  //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc1 = (ewNotFull1(1)), //The ew direction recieves under the same conditions
							ewShouldDec0 = (nsNotFull1(2)),  // Ew sends if the ns direction is not full
							noc[0].ewLockedns = !nsNotFull(2), // Ew is locked to ns if it is unable to send
							nsShouldInc2 = (nsNotFull1(2)), //The ns direction receives if it is not full
							noc[0].nsPriority = nsNotFull(2),  //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec0 = (nsNotEmpty1(0)), // Ns sends if it is not empty
							//totalFlitsDelivered0 += nsNotEmpty1(0),
							optimalRuns0 += ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
				=} 


				}	
			}

		}

		

		else{

			if(noc[0].ewLockedns) {

				tick palt { 
				//Local and EW both send to 2	
				:(1/3): {=	noc[0].ewLockedns = (localNotEmpty(0)) || (!localNotEmpty(0) && nsNotFull(2)),                //The ew buffer gets locked in the ns direction if local is not empty 
							noc[0].localPriority = (localNotEmpty(0) && !nsNotFull(2)) || (!localNotEmpty(0) && nsNotFull(2)),   //Local remains in priority if it is non-empty and is unable to send
							noc[0].localLockedns = (localNotEmpty(0) && !nsNotFull(2)), // Local gets locked to ns under the same conditions
							noc[0].localLen -= (localNotEmpty1(0))*(nsNotFull1(2)),  	//Local sends the ns direction if it is not empty, and the receiving buffer is not full
							nsShouldInc2 = (nsNotFull1(2)),   //The ns direction receives if it is not full (either from ew or local)
							ewShouldDec0 = localNotEmpty0(0)*(nsNotFull1(2)),		//Ew sends if local is empty and the ns direction is not full
							nsShouldDec0 = (nsNotEmpty1(0)), 		//Ns sends local if it is not empty
							noc[0].nsPriority = !localNotEmpty(0) && nsNotFull(2)
							//totalFlitsDelivered0 += nsNotEmpty1(0)
						=}		

				//Local has a 1 or 3 and EW has a 2
				:(2/3):  {= noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1), //Local is locked in the ew direction if it is unable to send
							noc[0].localPriority = (localNotEmpty(0) && !ewNotFull(1)) || (!localNotEmpty(0) && nsNotFull(2)) || ( (localNotEmpty(0) && ewNotFull(1) && (nsNotFull(2)))), //Local remains in priority under the same conditions
							noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), //The ew direction recieves under the same conditions
							ewShouldDec0 = (nsNotFull1(2)),  // Ew sends if the ns direction is not full
							noc[0].ewLockedns = !nsNotFull(2), // Ew is locked to ns if it is unable to send
							nsShouldInc2 = (nsNotFull1(2)), //The ns direction receives if it is not full
							noc[0].nsPriority = nsNotFull(2),  //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec0 = (nsNotEmpty1(0)), // Ns sends if it is not empty
							//totalFlitsDelivered0 += nsNotEmpty1(0),
							optimalRuns0 += localNotEmpty1(0)*ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
				=} 


				}	


			}

			else {

				tick palt { 
				//Local and EW both send to 2	
				:(1/6):  {= noc[0].ewLockedns = (localNotEmpty(0)) || (!localNotEmpty(0) && nsNotFull(2)),                //The ew buffer gets locked in the ns direction if local is not empty 
							noc[0].localPriority = (localNotEmpty(0) && !nsNotFull(2)) || (!localNotEmpty(0) && nsNotFull(2)),   //Local remains in priority if it is non-empty and is unable to send
							noc[0].localLockedns = (localNotEmpty(0) && !nsNotFull(2)), // Local gets locked to ns under the same conditions
							noc[0].localLen -= (localNotEmpty1(0))*(nsNotFull1(2)),  	//Local sends the ns direction if it is not empty, and the receiving buffer is not full
							nsShouldInc2 = (nsNotFull1(2)),   //The ns direction receives if it is not full (either from ew or local)
							ewShouldDec0 = localNotEmpty0(0)*(nsNotFull1(2)),		//Ew sends if local is empty and the ns direction is not full
							nsShouldDec0 = (nsNotEmpty1(0)), 		//Ns sends local if it is not empty
							noc[0].nsPriority = !localNotEmpty(0) && nsNotFull(2)
							//totalFlitsDelivered0 += nsNotEmpty1(0)
						=}	

				//Local Sends to 2, EW to 0
				:(1/6):  {= noc[0].localLockedns = localNotEmpty(0) && !nsNotFull(2), //Local is locked in the ns direction if it is unable to send
							noc[0].localPriority = (localNotEmpty(0) && !nsNotFull(2)) || (localNotEmpty(0) && !nsNotEmpty(0)) || ( ( (localNotEmpty(0)) && (nsNotFull(2)) ) && !nsNotEmpty(0)), //Local remains in priority under the same conditions
							noc[0].localLen -= (localNotEmpty1(0))*(nsNotFull1(2)),  //Local sends the ns direction if it is not empty, and the receiving buffer is not full
							nsShouldInc2 = (nsNotFull1(2))*(localNotEmpty1(0)), //The ns direction receives if it is not full and local is not empty
							ewShouldDec0 = nsNotEmpty0(0), //Ew sends local if the ns buffer is empty
							noc[0].ewLockedlocal = nsNotEmpty(0), //Ew gets locked to local if the ns buffer is not empty
							noc[0].nsPriority = !nsNotEmpty(0), //Ns remains in priority if it is empty
							nsShouldDec0 = (nsNotEmpty1(0))    // Ns sends if it is not empty
							//totalFlitsDelivered0 += 1
						=}					
				

				//Local has a 1 or 3 and EW has a 0	
				:(1/3):  {= noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1), //Local is locked in the ew direction if it is unable to send
							noc[0].localPriority = (localNotEmpty(0) && !ewNotFull(1)) || (localNotEmpty(0) && !nsNotEmpty(0)) || ( ( (localNotEmpty(0)) && (ewNotFull(1)) ) && !nsNotEmpty(0)), //Local remains in priority under the same conditions
							noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), //The ew direction receives under the same conditions
							noc[0].ewLockedlocal = nsNotEmpty(0), //The ew buffer is locked into the local direction if the ns buffer is not empty
							noc[0].nsPriority = !nsNotEmpty(0),  //The ns buffer remains in priority if it is empty
							nsShouldDec0 = (nsNotEmpty1(0)),	//Ns sneds if it is not empty
							ewShouldDec0 = nsNotEmpty0(0)		//Ew sends if 
							//totalFlitsDelivered0 += 1
				=}	

				//Local has a 1 or 3 and EW has a 2
				:(1/3):  {= noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1), //Local is locked in the ew direction if it is unable to send
							noc[0].localPriority = (localNotEmpty(0) && !ewNotFull(1)) || (!localNotEmpty(0) && nsNotFull(2)) || ( (localNotEmpty(0) && ewNotFull(1) && (nsNotFull(2)))), //Local remains in priority under the same conditions
							noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), //The ew direction recieves under the same conditions
							ewShouldDec0 = (nsNotFull1(2)),  // Ew sends if the ns direction is not full
							noc[0].ewLockedns = !nsNotFull(2), // Ew is locked to ns if it is unable to send
							nsShouldInc2 = (nsNotFull1(2)), //The ns direction receives if it is not full
							noc[0].nsPriority = nsNotFull(2),  //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec0 = (nsNotEmpty1(0)), // Ns sends if it is not empty
							//totalFlitsDelivered0 += nsNotEmpty1(0),
							optimalRuns0 += localNotEmpty1(0)*ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
				=} 


				}	
			}
		}



	}

	else if ((noc[0].localPriority == false) && (noc[0].nsPriority == false)) {

			if(noc[0].localLockedns) {

							if (noc[0].ewLockedlocal) {
								tick {= noc[0].localLockedns = !nsNotFull(2),
									noc[0].localPriority = !nsNotFull(2),
									noc[0].localLen -= (nsNotFull1(2)),  
									nsShouldInc2 = (nsNotFull1(2)), 
									ewShouldDec0 = 1, 
									noc[0].ewLockedlocal = false,
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0) 
								=} 

							}

							else if (noc[0].ewLockedns) {

									tick {= noc[0].localPriority = nsNotFull(2), 
										noc[0].localLockedns = true, 
										ewShouldDec0 = nsNotFull1(2), 
										noc[0].ewLockedns = !nsNotFull(2),
										nsShouldInc2 = nsNotFull1(2), 
										nsShouldDec0 = (nsNotEmpty1(0))
										//totalFlitsDelivered0 += nsNotEmpty1(0)
									=}

							}

							else {

								tick palt{
								//Local and EW both send to 2
								:(1/2):  {= noc[0].localPriority = nsNotFull(2), 
										noc[0].localLockedns = true, 
										ewShouldDec0 = nsNotFull1(2), 
										noc[0].ewLockedns = !nsNotFull(2),
										nsShouldInc2 = nsNotFull1(2), 
										nsShouldDec0 = (nsNotEmpty1(0))
										//totalFlitsDelivered0 += nsNotEmpty1(0)
										=}			

								//Local Sends to 2, EW to 0
								:(1/2):  {= noc[0].localLockedns = !nsNotFull(2),
											noc[0].localPriority = !nsNotFull(2),
											noc[0].localLen -= (nsNotFull1(2)),  
											nsShouldInc2 = (nsNotFull1(2)), 
											ewShouldDec0 = 1, 
											//totalFlitsDelivered0 += 1,
											noc[0].nsPriority = nsNotEmpty(0) 
										=} 				

							}

						}

			}

			else if (noc[0].localLockedew) {


					if (noc[0].ewLockedlocal) {

							// Local Sens EW and EW sends local 
							tick {=  noc[0].localLockedew = !ewNotFull(1),
										noc[0].localPriority = !ewNotFull(1),
										noc[0].localLen -= (ewNotFull1(1)),  
										ewShouldInc1 = (ewNotFull1(1)), 
										noc[0].ewLockedlocal = !ewNotFull(1),
										ewShouldDec0 = 1, 
										//totalFlitsDelivered0 += 1,
										noc[0].nsPriority = nsNotEmpty(0) 
									=}  

						

					}
					else if (noc[0].ewLockedns) {

							//Local sends EW and EW sends NS
							tick {=  noc[0].localLockedew = !ewNotFull(1),
										noc[0].localPriority = !ewNotFull(1) && nsNotFull(2),
										noc[0].localLen -= (ewNotFull1(1)),  
										ewShouldInc1 = (ewNotFull1(1)), 
										ewShouldDec0 = nsNotFull1(2), 
										noc[0].ewLockedns = !nsNotFull(2),
										nsShouldInc2 = nsNotFull1(2), 
										nsShouldDec0 = (nsNotEmpty1(0)), 
										//totalFlitsDelivered0 += nsNotEmpty1(0),
										optimalRuns0 += ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
									=} 
	

					}
					else {

						tick palt{
				
					

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {= 		noc[0].localLockedew = !ewNotFull(1),
										noc[0].localPriority = !ewNotFull(1),
										noc[0].localLen -= (ewNotFull1(1)),  
										ewShouldInc1 = (ewNotFull1(1)), 
										noc[0].ewLockedlocal = !ewNotFull(1),
										ewShouldDec0 = 1, 
										//totalFlitsDelivered0 += 1,
										noc[0].nsPriority = nsNotEmpty(0) 
								=}

						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {= 		noc[0].localLockedew = !ewNotFull(1),
										noc[0].localPriority = !ewNotFull(1) && nsNotFull(2),
										noc[0].localLen -= (ewNotFull1(1)),  
										ewShouldInc1 = (ewNotFull1(1)), 
										ewShouldDec0 = nsNotFull1(2), 
										noc[0].ewLockedns = !nsNotFull(2),
										nsShouldInc2 = nsNotFull1(2), 
										nsShouldDec0 = (nsNotEmpty1(0)), 
										//totalFlitsDelivered0 += nsNotEmpty1(0),
										optimalRuns0 += ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
						=} 

					}
			}

			


			} 

			else {

				if (noc[0].ewLockedlocal) {

					tick palt {
						
						//Local sends NS and EW sends local
						:(1/3):  {= noc[0].localLockedns = localNotEmpty(0) && !nsNotFull(2),
									noc[0].localPriority = localNotEmpty(0) && !nsNotFull(2),
									noc[0].localLen -= (localNotEmpty1(0))*(nsNotFull1(2)),  
									nsShouldInc2 = (nsNotFull1(2))*(localNotEmpty1(0)), 
									ewShouldDec0 = 1, 
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0) 
								=} 

						// Local Sens EW and EW sends local 
						:(2/3):  {=  noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localPriority = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), 
									ewShouldDec0 = 1, 
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0) 
								=}  

					}

				}
				else if (noc[0].ewLockedns) {

					tick palt {
						//Local sends NS and EW sends NS
						:(1/3):  {= noc[0].localPriority =localNotEmpty(0), 
									noc[0].localLockedns = localNotEmpty(0), 
									noc[0].ewLockedns = !nsNotFull(2),
									ewShouldDec0 = nsNotFull1(2), 
									nsShouldInc2 = nsNotFull1(2), 
									nsShouldDec0 = (nsNotEmpty1(0))
									//totalFlitsDelivered0 += nsNotEmpty1(0)
								=}
						//Local sends EW and EW sends NS
						:(2/3):  {=  noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localPriority = localNotEmpty(0) && !ewNotFull(1) && nsNotFull(2),
									noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), 
									ewShouldDec0 = nsNotFull1(2), 
									noc[0].ewLockedns = !nsNotFull(2),
									nsShouldInc2 = nsNotFull1(2), 
									nsShouldDec0 = (nsNotEmpty1(0)),
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									optimalRuns0 += localNotEmpty1(0)*ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
								=} 


					}

				}
				else {

					tick palt{
					//Local and EW both send to 2
					:(1/6):  {= 		noc[0].localPriority =localNotEmpty(0), 
									noc[0].localLockedns = localNotEmpty(0), 
									noc[0].ewLockedns = !nsNotFull(2),
									ewShouldDec0 = nsNotFull1(2), 
									nsShouldInc2 = nsNotFull1(2), 
									nsShouldDec0 = (nsNotEmpty1(0)) 
									//totalFlitsDelivered0 += nsNotEmpty1(0)
							=}			

					//Local Sends to 2, EW to 0
					:(1/6):  {= 		noc[0].localLockedns = localNotEmpty(0) && !nsNotFull(2),
									noc[0].localPriority = localNotEmpty(0) && !nsNotFull(2),
									noc[0].localLen -= (localNotEmpty1(0))*(nsNotFull1(2)),  
									nsShouldInc2 = (nsNotFull1(2))*(localNotEmpty1(0)), 
									ewShouldDec0 = 1, 
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0) 
							=}					
				

					//Local has a 1 or 3 and EW has a 0
					:(1/3):  {= 		noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localPriority = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), 
									ewShouldDec0 = 1, 
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0) 
							=}

					//Local has a 1 or 3 and EW has a 2
					:(1/3):  {= 		noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localPriority = localNotEmpty(0) && !ewNotFull(1) && nsNotFull(2),
									noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), 
									ewShouldDec0 = nsNotFull1(2), 
									noc[0].ewLockedns = !nsNotFull(2),
									nsShouldInc2 = nsNotFull1(2), 
									nsShouldDec0 = (nsNotEmpty1(0)), 
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									optimalRuns0 += localNotEmpty1(0)*ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
					=} 

				}
		}

		}

	}


	else if ((noc[0].localPriority == false) && (noc[0].nsPriority == true)) {

		if(noc[0].localLockedns) {

			if(noc[0].ewLockedns) {

				tick {= noc[0].localPriority = nsNotFull(2), 
					noc[0].ewLockedns = !nsNotFull(2),
					ewShouldDec0 = nsNotFull1(2), 
					nsShouldInc2 = nsNotFull1(2), 
					nsShouldDec0 = (nsNotEmpty1(0)),
					//totalFlitsDelivered0 += nsNotEmpty1(0),
					noc[0].nsPriority = nsNotFull(2)
				=} 


			}
			//Logically determined that ew cannot be locked local
			else {

			tick palt {	//Local and EW both send to 2
			:(1/2):  {= noc[0].localPriority = nsNotFull(2), 
					noc[0].ewLockedns = !nsNotFull(2),
					ewShouldDec0 = nsNotFull1(2), 
					nsShouldInc2 = nsNotFull1(2), 
					nsShouldDec0 = (nsNotEmpty1(0)),
					//totalFlitsDelivered0 += nsNotEmpty1(0),
					noc[0].nsPriority = nsNotFull(2)
					=}
					//Local Sends to 2, EW to 0
			:(1/2):  {= noc[0].localPriority = !nsNotFull(2),
						noc[0].localLockedns = !nsNotFull(2),
						noc[0].localLen -= nsNotFull1(2),  
						nsShouldInc2 = (nsNotFull1(2)), 
						ewShouldDec0 = nsNotEmpty0(0),
						noc[0].ewLockedns = nsNotEmpty(0),
						nsShouldDec0 = nsNotEmpty1(0), 
						//totalFlitsDelivered0 += 1,
						noc[0].nsPriority = !nsNotEmpty(0)
				
					=}	
			}
			}



		}

		else if(noc[0].localLockedew) {

			if (noc[0].ewLockedns) {

						//Local sends EW and EW sends NS
						tick {=  noc[0].localPriority = !ewNotFull(1) && nsNotFull(2),
									noc[0].localLockedew = !ewNotFull(1),
									noc[0].localLen -= (ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1)), 
									noc[0].ewLockedns = !nsNotFull(2),
									ewShouldDec0 = nsNotFull1(2), 
									nsShouldInc2 = nsNotFull1(2), 
									nsShouldDec0 = (nsNotEmpty1(0)), 
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									noc[0].nsPriority = nsNotFull(2),
									optimalRuns0 += ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
								=} 


					

				}
			else {
				
					tick palt {				
				

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {=  noc[0].localPriority = !ewNotFull(1) && !nsNotEmpty(0), 
									noc[0].localLockedew = !ewNotFull(1),
									noc[0].localLen -= (ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1)), 
									nsShouldDec0 = nsNotEmpty1(0),
									noc[0].nsPriority = !nsNotEmpty(0), 
									ewShouldDec0 = nsNotEmpty0(0), 
									noc[0].ewLockedlocal = nsNotEmpty(0)
									//totalFlitsDelivered0 += 1
								=}	

						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {= noc[0].localPriority = !ewNotFull(1) && nsNotFull(2),
									noc[0].localLockedew = !ewNotFull(1),
									noc[0].localLen -= (ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1)), 
									noc[0].ewLockedns = !nsNotFull(2),
									ewShouldDec0 = nsNotFull1(2), 
									nsShouldInc2 = nsNotFull1(2), 
									nsShouldDec0 = (nsNotEmpty1(0)), 
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									noc[0].nsPriority = nsNotFull(2),
									optimalRuns0 += ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
								=}  


					}
				}

		}


		else {
		
			 if (noc[0].ewLockedns) {

					tick palt {
						//Local sends NS and EW sends NS
						:(1/3):  tick {= noc[0].localPriority = localNotEmpty(0) && nsNotFull(2),
									noc[0].localLockedns = localNotEmpty(0),
									noc[0].ewLockedns = !nsNotFull(2),
									ewShouldDec0 = nsNotFull1(2), 
									nsShouldInc2 = nsNotFull1(2), 
									nsShouldDec0 = (nsNotEmpty1(0)),
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									noc[0].nsPriority = nsNotFull(2)
								=} 
						//Local sends EW and EW sends NS
						:(2/3):  {=  noc[0].localPriority = localNotEmpty(0) && !ewNotFull(1) && nsNotFull(2),
									noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), 
									noc[0].ewLockedns = !nsNotFull(2),
									ewShouldDec0 = nsNotFull1(2), 
									nsShouldInc2 = nsNotFull1(2), 
									nsShouldDec0 = (nsNotEmpty1(0)), 
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									noc[0].nsPriority = nsNotFull(2),
									optimalRuns0 += localNotEmpty1(0)*ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
								=} 


					}

				}
			else {
				
					tick palt {
						//Local and EW both send to 2
						:(1/6):  {= noc[0].localPriority = localNotEmpty(0) && nsNotFull(2),
									noc[0].localLockedns = localNotEmpty(0),
									noc[0].ewLockedns = !nsNotFull(2),
									ewShouldDec0 = nsNotFull1(2), 
									nsShouldInc2 = nsNotFull1(2), 
									nsShouldDec0 = (nsNotEmpty1(0)),
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									noc[0].nsPriority = nsNotFull(2)
								=}			
						//Local Sends to 2, EW to 0
						:(1/6):  {= noc[0].localPriority = !nsNotFull(2) && localNotEmpty(0) && !nsNotEmpty(0), 
									noc[0].localLockedns = localNotEmpty(0) && !nsNotFull(2),
									noc[0].localLen -= (localNotEmpty1(0))*(nsNotFull1(2)),  
									nsShouldInc2 = (nsNotFull1(2))*(localNotEmpty1(0)), 
									ewShouldDec0 = nsNotEmpty0(0),
									noc[0].ewLockedlocal = nsNotEmpty(0),
									nsShouldDec0 = nsNotEmpty1(0), 
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = !nsNotEmpty(0) 
								=}					
				

						//Local has a 1 or 3 and EW has a 0
						:(1/3):  {=  noc[0].localPriority = !ewNotFull(1) && localNotEmpty(0) && !nsNotEmpty(0), 
									noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), 
									nsShouldDec0 = nsNotEmpty1(0),
									noc[0].nsPriority = !nsNotEmpty(0), 
									ewShouldDec0 = nsNotEmpty0(0),
									noc[0].ewLockedlocal = nsNotEmpty(0)
									//totalFlitsDelivered0 += 1
								=}	

						//Local has a 1 or 3 and EW has a 2
						:(1/3):  {= noc[0].localPriority = localNotEmpty(0) && !ewNotFull(1) && nsNotFull(2),
									noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), 
									noc[0].ewLockedns = !nsNotFull(2),
									ewShouldDec0 = nsNotFull1(2), 
									nsShouldInc2 = nsNotFull1(2), 
									nsShouldDec0 = (nsNotEmpty1(0)), 
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									noc[0].nsPriority = nsNotFull(2),
									optimalRuns0 += localNotEmpty1(0)*ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
								=}  


					}
				}

		}

	}
	else {   //Localpriority == true && nsPriority == false

		if(noc[0].localLockedns) {

			if (noc[0].ewLockedlocal) {


						 //Local sends NS and EW sends local
								tick {= noc[0].localPriority = true, 
									noc[0].localLockedns = !nsNotFull(2), 
									noc[0].localLen -= (nsNotFull1(2)),
									nsShouldInc2 = (nsNotFull1(2)), 
									ewShouldDec0 = 1, 
									noc[0].ewLockedlocal = false,
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0) 
								=} 

				}

				else if(noc[0].ewLockedns) {

							tick {= noc[0].localPriority = !nsNotFull(2), 
									noc[0].localLockedns = !nsNotFull(2), 
									noc[0].localLen -= (nsNotFull1(2)),  
									nsShouldInc2 = (nsNotFull1(2)), 
									noc[0].ewLockedns = true,
									nsShouldDec0 = (nsNotEmpty1(0)), 
									noc[0].nsPriority = false
									//totalFlitsDelivered0 += nsNotEmpty1(0)
								=}	


				}


				else {


					tick palt {
						//Local and EW both send to 2
						:(1/2):  {= 	noc[0].localPriority = !nsNotFull(2), 
									noc[0].localLockedns = !nsNotFull(2), 
									noc[0].localLen -= (nsNotFull1(2)),  
									nsShouldInc2 = (nsNotFull1(2)), 
									noc[0].ewLockedns = true,
									nsShouldDec0 = (nsNotEmpty1(0)), 
									noc[0].nsPriority = false
									//totalFlitsDelivered0 += nsNotEmpty1(0)
								=}	
						//Local Sends to 2, EW to 0
						:(1/2):  {= noc[0].localPriority = true, 
									noc[0].localLockedns = !nsNotFull(2), 
									noc[0].localLen -= (nsNotFull1(2)),
									nsShouldInc2 = (nsNotFull1(2)), 
									ewShouldDec0 = 1, 
									noc[0].ewLockedlocal = false,
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0) 
								=}					


					}
				}

		}

		else if(noc[0].localLockedew) {

			if (noc[0].ewLockedlocal) {

						// Local Sends EW and EW sends local
					tick {= 	noc[0].localPriority = true, 
						noc[0].localLockedew = !ewNotFull(1),
						noc[0].localLen -= (ewNotFull1(1)),  
						ewShouldInc1 = (ewNotFull1(1)), 
						ewShouldDec0 = 1, 
						noc[0].ewLockedlocal = false,
						//totalFlitsDelivered0 += 1,
						noc[0].nsPriority = nsNotEmpty(0) 
					=}  

					

				}

				else if(noc[0].ewLockedns) {

	
								//Local has a 1 or 3 and EW has a 2
						tick {=  		noc[0].localPriority = !(ewNotFull(1) && !nsNotFull(2)), 
									noc[0].localLockedew = !ewNotFull(1),
									noc[0].localLen -= (ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1)), 
									ewShouldDec0 = (nsNotFull1(2)), 
									noc[0].ewLockedlocal = !nsNotFull(2),
									nsShouldInc2 = (nsNotFull1(2)), 
									nsShouldDec0 = (nsNotEmpty1(0)), 
									noc[0].nsPriority = false,
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									optimalRuns0 += ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
								=}  


				}


				else {


					tick palt {				
				

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {= 	noc[0].localPriority = true, 
									noc[0].localLockedew = !ewNotFull(1),
									noc[0].localLen -= (ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1)), 
									ewShouldDec0 = 1, 
									noc[0].ewLockedlocal = false,
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0)
								=} 			
						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {=  noc[0].localPriority = !(ewNotFull(1) && !nsNotFull(2)), 
									noc[0].localLockedew = !ewNotFull(1),
									noc[0].localLen -= (ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1)), 
									ewShouldDec0 = (nsNotFull1(2)), 
									noc[0].ewLockedlocal = !nsNotFull(2),
									nsShouldInc2 = (nsNotFull1(2)), 
									nsShouldDec0 = (nsNotEmpty1(0)), 
									noc[0].nsPriority = false,
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									optimalRuns0 += ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
								=}  


					}
				}


		}
		

		else {
			 if (noc[0].ewLockedlocal) {

					tick palt {
						 //Local sends NS and EW sends local
						:(1/3):  tick {= noc[0].localPriority = true, 
									noc[0].localLockedns = localNotEmpty(0) && !nsNotFull(2), 
									noc[0].localLen -= (nsNotFull1(2))*(localNotEmpty1(0)),
									nsShouldInc2 = (nsNotFull1(2))*(localNotEmpty1(0)), 
									ewShouldDec0 = 1,
									noc[0].ewLockedlocal = false, 
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0) 
								=} 
						// Local Sends EW and EW sends local
						:(2/3):  tick {= noc[0].localPriority = true, 
									noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), 
									ewShouldDec0 = 1, 
									noc[0].ewLockedlocal = false,
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0) 
								=}  

					}

				}

				else if(noc[0].ewLockedns) {


						tick palt {
						//Local and EW both send to 2
						:(1/3):  {= noc[0].localPriority = (localNotEmpty(0) && !nsNotFull(2)) || (!localNotEmpty(0) && nsNotFull(2)), 
									noc[0].localLockedns = localNotEmpty(0) && !nsNotFull(2), 
									noc[0].localLen -= (localNotEmpty1(0))*(nsNotFull1(2)),  
									nsShouldInc2 = (nsNotFull1(2)), 
									noc[0].ewLockedns = localNotEmpty(0) || (!localNotEmpty(0) && !nsNotFull(2)),
									ewShouldDec0 = localNotEmpty0(0)*nsNotFull1(2),
									nsShouldDec0 = (nsNotEmpty1(0)), 
									noc[0].nsPriority = false
									//totalFlitsDelivered0 += nsNotEmpty1(0)
								=}	
								//Local has a 1 or 3 and EW has a 2
						:(2/3):  {=  noc[0].localPriority = (!ewNotFull(1) && localNotEmpty(0)) || (!localNotEmpty(0) && nsNotFull(2)) || (ewNotFull(1) && localNotEmpty(0) && nsNotFull(2)), 
									noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), 
									ewShouldDec0 = (nsNotFull1(2)), 
									noc[0].ewLockedns = !nsNotFull(2),
									nsShouldInc2 = (nsNotFull1(2)), 
									nsShouldDec0 = (nsNotEmpty1(0)), 
									noc[0].nsPriority = false,
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									optimalRuns0 += ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
								=}  
						}


				}


				else {


					tick palt {
						//Local and EW both send to 2
						:(1/6):  {= noc[0].localPriority = (localNotEmpty(0) && !nsNotFull(2)) || (!localNotEmpty(0) && nsNotFull(2)), 
									noc[0].localLockedns = localNotEmpty(0) && !nsNotFull(2), 
									noc[0].localLen -= (localNotEmpty1(0))*(nsNotFull1(2)),  
									nsShouldInc2 = (nsNotFull1(2)), 
									noc[0].ewLockedns = localNotEmpty(0) || (!localNotEmpty(0) && !nsNotFull(2)),
									ewShouldDec0 = localNotEmpty0(0)*nsNotFull1(2),
									nsShouldDec0 = (nsNotEmpty1(0)), 
									noc[0].nsPriority = false
									//totalFlitsDelivered0 += nsNotEmpty1(0)
								=}	
						//Local Sends to 2, EW to 0
						:(1/6):  {= noc[0].localPriority = true, 
									noc[0].localLockedns = localNotEmpty(0) && !nsNotFull(2), 
									noc[0].localLen -= (nsNotFull1(2))*(localNotEmpty1(0)),
									nsShouldInc2 = (nsNotFull1(2))*(localNotEmpty1(0)), 
									ewShouldDec0 = 1,
									noc[0].ewLockedlocal = false, 
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0) 
								=}					
				

						//Local has a 1 or 3 and EW has a 0
						:(1/3):  {= noc[0].localPriority = true, 
									noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), 
									ewShouldDec0 = 1, 
									noc[0].ewLockedlocal = false,
									//totalFlitsDelivered0 += 1,
									noc[0].nsPriority = nsNotEmpty(0) 
								=} 			
						//Local has a 1 or 3 and EW has a 2
						:(1/3):  {=  noc[0].localPriority = (!ewNotFull(1) && localNotEmpty(0)) || (!localNotEmpty(0) && nsNotFull(2)) || (ewNotFull(1) && localNotEmpty(0) && nsNotFull(2)), 
									noc[0].localLockedew = localNotEmpty(0) && !ewNotFull(1),
									noc[0].localLen -= (localNotEmpty1(0))*(ewNotFull1(1)),  
									ewShouldInc1 = (ewNotFull1(1))*(localNotEmpty1(0)), 
									ewShouldDec0 = (nsNotFull1(2)), 
									noc[0].ewLockedns = !nsNotFull(2),
									nsShouldInc2 = (nsNotFull1(2)), 
									nsShouldDec0 = (nsNotEmpty1(0)), 
									noc[0].nsPriority = false,
									//totalFlitsDelivered0 += nsNotEmpty1(0),
									optimalRuns0 += ewNotFull1(1)*nsNotFull1(2)*nsNotEmpty1(0)
								=}  


					}
				}
		}


	}





}

process arbiter1(){

	//tick {= localNotEmptyOne = (noc[1].localLen > 0) ? 1 : 0 =};

	if (noc[1].ewLen == 0) {		//If the EW buffer of the NoC is empty

		if (noc[1].localLockedns == true) {		//If the local buffer is locked sending NS

			tick {= noc[1].localLockedns = !nsNotFull(3),   //Sets the priority to false if it was able to send to the ns buffer of the NoC in the y direction
				noc[1].localPriority = !nsNotFull(3) || noc[1].localPriority, 		//Local gets priority if it is unable to send
				noc[1].localLen -= nsNotFull1(3),      //Local sends a flit ns if the receiving buffer is not full
				nsShouldInc3 = (nsNotFull1(3)),   //The ns direction receives the flit if it is not already full
				nsShouldDec1 = (nsNotEmpty1(1)) 						//The ns buffer sends a flit to local if it is not empty
				//totalFlitsDelivered1 += nsNotEmpty1(1)
			=}

		}

		else if (noc[1].localLockedew) {

			tick {=  			noc[1].localLockedew = !ewNotFull(0),  // Local is locked it if has a flit and is unable to send it
							noc[1].localPriority = !ewNotFull(0) || noc[1].localPriority,   // Local gets priority under the same conditions		
							noc[1].localLen -= (ewNotFull1(0)),   //Local sends a flit to the ew direction if it is not empty and the receiving buffer is not full
							ewShouldInc0 = (ewNotFull1(0)),  //The ew direction receives it under the same conditions
							nsShouldDec1 = (nsNotEmpty1(1))  //The ns buffer sends a flit to local if it is not empty
							//totalFlitsDelivered1 += nsNotEmpty1(1)	
							
			=}


		} 

		else {
			tick palt {
				//Local sends in the NS direction
				:(1/3): {=  noc[1].localLockedns = localNotEmpty(1) && !nsNotFull(3),  // Local is locked it if has a flit and is unable to send it
							noc[1].localPriority = (localNotEmpty(1) && !nsNotFull(3)) || noc[1].localPriority,   // Local gets priority under the same conditions
							noc[1].localLen -= (localNotEmpty1(1))*(nsNotFull1(3)),   //Local sends a flit to the ns direction if it is not empty and the receiving buffer is not full
					   		nsShouldInc3 = (nsNotFull1(3))*(localNotEmpty1(1)),  //The ns direction receives the flit under the same conditions
							nsShouldDec1 = (nsNotEmpty1(1))    //The ns buffer sends a flit to local if it is not empty	
							//totalFlitsDelivered1 += nsNotEmpty1(1)
						=}
				//Local sends to the ew direction
				:(2/3): {=  noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0),  // Local is locked it if has a flit and is unable to send it
							noc[1].localPriority = (localNotEmpty(1) && !ewNotFull(0)) || noc[1].localPriority,   // Local gets priority under the same conditions
							noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   //Local sends a flit to the ew direction if it is not empty and the receiving buffer is not full
							ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  //The ew direction receives it under the same conditions
							nsShouldDec1 = (nsNotEmpty1(1))  //The ns buffer sends a flit to local if it is not empty
							//totalFlitsDelivered1 += nsNotEmpty1(1)
							
						=}
			}
		}

	}
	else if ((noc[1].localPriority == true) && (noc[1].nsPriority == true)) {

		if (noc[1].localLockedns == true) {

			if (noc[1].ewLockedns) {

				tick {= noc[1].localLockedns = !nsNotFull(3),  	//Local stays locked if it is unable to send
					noc[1].localPriority = !nsNotFull(3), 
						noc[1].localLen -= nsNotFull1(3),   //Local sends if the ns direction is not already full
						nsShouldInc3 = nsNotFull1(3),  //The ns direction receives under the same conditions
						noc[1].nsPriority = false, 
						noc[1].ewLockedns = true,  
						nsShouldDec1 = (nsNotEmpty1(1))    //The ns buffer sends a flit to local if it is not empty 
						//totalFlitsDelivered1 += nsNotEmpty1(1)
				=}

			}

			else {
			tick palt {
			// Local and EW both send ns	
			:(1/2):  {= noc[1].localLockedns = !nsNotFull(3),  	//Local stays locked if it is unable to send
						noc[1].localLen -= nsNotFull1(3),   //Local sends if the ns direction is not already full
						nsShouldInc3 = nsNotFull1(3),  //The ns direction receives under the same conditions
						nsShouldDec1 = (nsNotEmpty1(1)),    //The ns buffer sends a flit to local if it is not empty
						noc[1].nsPriority = false, 
						//totalFlitsDelivered1 += nsNotEmpty1(1), 
						noc[1].ewLockedns = true,  			//The Ew buffer is locked to send in the ns direction
						noc[1].localPriority = !nsNotFull(3) //Local remains in priority if it did not send
					=}  
			 
			 //Local sends ns,  and EW sends to to local
			:(1/2):  {= noc[1].localLockedns =  !nsNotFull(3),   //Local stays locked if it is unable to send
						noc[1].localPriority = !(nsNotFull(3) && nsNotEmpty(1)),  //Local only loses priority if it sends and ew doesn't
						noc[1].localLen -= (nsNotFull1(3)),   //Local sends ns if it isn't empty and ns isn't full
						nsShouldInc3 = (nsNotFull1(3)),  //Ns receives under the same conditions
						ewShouldDec1 = nsNotEmpty0(1),  	//Ew sends if the ns buffer is empty
				
						noc[1].ewLockedlocal = nsNotEmpty(1),  	//Local is locked if the ns buffer is not empty
						noc[1].nsPriority = !nsNotEmpty(1),      //NS loses priority if it sends
						nsShouldDec1 = (nsNotEmpty1(1))  		//Ns sends local if it isn't empty
						//totalFlitsDelivered1 += nsNotEmpty1(1)
					=}    
			}
		}

		}

		else if (noc[1].localLockedew) {

			if(noc[1].ewLockedns) {	

				//Local has a 1 or 3 and EW has a 2
				tick {= noc[1].localLockedew = !ewNotFull(0),  //Local is locked in the ew direction if it is unable to send
							noc[1].localPriority = !(!ewNotFull(0) && nsNotFull(3)),  //Local remains in priority under the same conditions
							noc[1].localLen -= (ewNotFull1(0)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc0 = (ewNotFull1(0)),  //The ew direction recieves under the same conditions
							ewShouldDec1 = (nsNotFull1(3)),   // Ew sends if the ns direction is not full
							noc[1].ewLockedns = !nsNotFull(3),  // Ew is locked to ns if it is unable to send
							nsShouldInc3 = (nsNotFull1(3)),  //The ns direction receives if it is not full
							noc[1].nsPriority = nsNotFull(3),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec1 = (nsNotEmpty1(1)),  // Ns sends if it is not empty
							//totalFlitsDelivered1 += nsNotEmpty1(1), 
							optimalRuns1 += ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)

				=} 


			}

			else {

				tick palt { 

				//Local has a 1 or 3 and EW has a 0	
				:(1/2):  {= noc[1].localLockedew = !ewNotFull(0),  //Local is locked in the ew direction if it is unable to send
							noc[1].localPriority = !(ewNotFull(0) && nsNotEmpty(1)),  //Local remains in priority under the same conditions
							noc[1].localLen -= (ewNotFull1(0)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc0 = (ewNotFull1(0)),  //The ew direction receives under the same conditions
							noc[1].ewLockedlocal = nsNotEmpty(1),  //The ew buffer is locked into the local direction if the ns buffer is not empty
							noc[1].nsPriority = !nsNotEmpty(1),   //The ns buffer remains in priority if it is empty
							nsShouldDec1 = (nsNotEmpty1(1)), 	//Ns sneds if it is not empty
							ewShouldDec1 = nsNotEmpty0(1) 		//Ew sends if 
							//totalFlitsDelivered1 += 1
				=}	

				//Local has a 1 or 3 and EW has a 2
				:(1/2):  {= noc[1].localLockedew = !ewNotFull(0),  //Local is locked in the ew direction if it is unable to send
							noc[1].localPriority = !(!ewNotFull(0) && nsNotFull(3)),  //Local remains in priority under the same conditions
							noc[1].localLen -= (ewNotFull1(0)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc0 = (ewNotFull1(0)),  //The ew direction recieves under the same conditions
							ewShouldDec1 = (nsNotFull1(3)),   // Ew sends if the ns direction is not full
							noc[1].ewLockedns = !nsNotFull(3),  // Ew is locked to ns if it is unable to send
							nsShouldInc3 = (nsNotFull1(3)),  //The ns direction receives if it is not full
							noc[1].nsPriority = nsNotFull(3),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec1 = (nsNotEmpty1(1)),  // Ns sends if it is not empty
							//totalFlitsDelivered1 += nsNotEmpty1(1), 
							optimalRuns1 += ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
				=} 


				}	
			}

		}

		

		else{

			if(noc[1].ewLockedns) {

				tick palt { 
				//Local and EW both send to 2	
				:(1/3): {=	noc[1].ewLockedns = (localNotEmpty(1)) || (!localNotEmpty(1) && nsNotFull(3)),                 //The ew buffer gets locked in the ns direction if local is not empty 
							noc[1].localPriority = (localNotEmpty(1) && !nsNotFull(3)) || (!localNotEmpty(1) && nsNotFull(3)),    //Local remains in priority if it is non-empty and is unable to send
							noc[1].localLockedns = (localNotEmpty(1) && !nsNotFull(3)),  // Local gets locked to ns under the same conditions
							noc[1].localLen -= (localNotEmpty1(1))*(nsNotFull1(3)),   	//Local sends the ns direction if it is not empty,  and the receiving buffer is not full
							nsShouldInc3 = (nsNotFull1(3)),    //The ns direction receives if it is not full (either from ew or local)
							ewShouldDec1 = localNotEmpty0(1)*(nsNotFull1(3)), 		//Ew sends if local is empty and the ns direction is not full
							nsShouldDec1 = (nsNotEmpty1(1)),  		//Ns sends local if it is not empty
							noc[1].nsPriority = !localNotEmpty(1) && nsNotFull(3) 
							//totalFlitsDelivered1 += nsNotEmpty1(1)
						=}		

				//Local has a 1 or 3 and EW has a 2
				:(2/3):  {= noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0),  //Local is locked in the ew direction if it is unable to send
							noc[1].localPriority = (localNotEmpty(1) && !ewNotFull(0)) || (!localNotEmpty(1) && nsNotFull(3)) || ( (localNotEmpty(1) && ewNotFull(0) && (nsNotFull(3)))),  //Local remains in priority under the same conditions
							noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  //The ew direction recieves under the same conditions
							ewShouldDec1 = (nsNotFull1(3)),   // Ew sends if the ns direction is not full
							noc[1].ewLockedns = !nsNotFull(3),  // Ew is locked to ns if it is unable to send
							nsShouldInc3 = (nsNotFull1(3)),  //The ns direction receives if it is not full
							noc[1].nsPriority = nsNotFull(3),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec1 = (nsNotEmpty1(1)),  // Ns sends if it is not empty
							//totalFlitsDelivered1 += nsNotEmpty1(1), 
							optimalRuns1 += localNotEmpty1(1)*ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
				=} 


				}	


			}

			else {

				tick palt { 
				//Local and EW both send to 2	
				:(1/6):  {= noc[1].ewLockedns = (localNotEmpty(1)) || (!localNotEmpty(1) && nsNotFull(3)),                 //The ew buffer gets locked in the ns direction if local is not empty 
							noc[1].localPriority = (localNotEmpty(1) && !nsNotFull(3)) || (!localNotEmpty(1) && nsNotFull(3)),    //Local remains in priority if it is non-empty and is unable to send
							noc[1].localLockedns = (localNotEmpty(1) && !nsNotFull(3)),  // Local gets locked to ns under the same conditions
							noc[1].localLen -= (localNotEmpty1(1))*(nsNotFull1(3)),   	//Local sends the ns direction if it is not empty,  and the receiving buffer is not full
							nsShouldInc3 = (nsNotFull1(3)),    //The ns direction receives if it is not full (either from ew or local)
							ewShouldDec1 = localNotEmpty0(1)*(nsNotFull1(3)), 		//Ew sends if local is empty and the ns direction is not full
							nsShouldDec1 = (nsNotEmpty1(1)),  		//Ns sends local if it is not empty
							noc[1].nsPriority = !localNotEmpty(1) && nsNotFull(3)
							//totalFlitsDelivered1 += nsNotEmpty1(1)
						=}	

				//Local Sends to 2,  EW to 0
				:(1/6):  {= noc[1].localLockedns = localNotEmpty(1) && !nsNotFull(3),  //Local is locked in the ns direction if it is unable to send
							noc[1].localPriority = (localNotEmpty(1) && !nsNotFull(3)) || (localNotEmpty(1) && !nsNotEmpty(1)) || ( ( (localNotEmpty(1)) && (nsNotFull(3)) ) && !nsNotEmpty(1)),  //Local remains in priority under the same conditions
							noc[1].localLen -= (localNotEmpty1(1))*(nsNotFull1(3)),   //Local sends the ns direction if it is not empty,  and the receiving buffer is not full
							nsShouldInc3 = (nsNotFull1(3))*(localNotEmpty1(1)),  //The ns direction receives if it is not full and local is not empty
							ewShouldDec1 = nsNotEmpty0(1),  //Ew sends local if the ns buffer is empty
							noc[1].ewLockedlocal = nsNotEmpty(1),  //Ew gets locked to local if the ns buffer is not empty
							noc[1].nsPriority = !nsNotEmpty(1),  //Ns remains in priority if it is empty
							nsShouldDec1 = (nsNotEmpty1(1))     // Ns sends if it is not empty
							//totalFlitsDelivered1 += 1
						=}					
				

				//Local has a 1 or 3 and EW has a 0	
				:(1/3):  {= noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0),  //Local is locked in the ew direction if it is unable to send
							noc[1].localPriority = (localNotEmpty(1) && !ewNotFull(0)) || (localNotEmpty(1) && !nsNotEmpty(1)) || ( ( (localNotEmpty(1)) && (ewNotFull(0)) ) && !nsNotEmpty(1)),  //Local remains in priority under the same conditions
							noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  //The ew direction receives under the same conditions
							noc[1].ewLockedlocal = nsNotEmpty(1),  //The ew buffer is locked into the local direction if the ns buffer is not empty
							noc[1].nsPriority = !nsNotEmpty(1),   //The ns buffer remains in priority if it is empty
							nsShouldDec1 = (nsNotEmpty1(1)), 	//Ns sneds if it is not empty
							ewShouldDec1 = nsNotEmpty0(1)		//Ew sends if 
							//totalFlitsDelivered1 += 1
				=}	

				//Local has a 1 or 3 and EW has a 2
				:(1/3):  {= noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0),  //Local is locked in the ew direction if it is unable to send
							noc[1].localPriority = (localNotEmpty(1) && !ewNotFull(0)) || (!localNotEmpty(1) && nsNotFull(3)) || ( (localNotEmpty(1) && ewNotFull(0) && (nsNotFull(3)))),  //Local remains in priority under the same conditions
							noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  //The ew direction recieves under the same conditions
							ewShouldDec1 = (nsNotFull1(3)),   // Ew sends if the ns direction is not full
							noc[1].ewLockedns = !nsNotFull(3),  // Ew is locked to ns if it is unable to send
							nsShouldInc3 = (nsNotFull1(3)),  //The ns direction receives if it is not full
							noc[1].nsPriority = nsNotFull(3),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec1 = (nsNotEmpty1(1)),  // Ns sends if it is not empty
							//totalFlitsDelivered1 += nsNotEmpty1(1), 
							optimalRuns1 += localNotEmpty1(1)*ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
				=} 


				}	
			}
		}



	}

	else if ((noc[1].localPriority == false) && (noc[1].nsPriority == false)) {

			if(noc[1].localLockedns) {

							if (noc[1].ewLockedlocal) {
								tick {= noc[1].localLockedns = !nsNotFull(3), 
									noc[1].localPriority = !nsNotFull(3), 
									noc[1].localLen -= (nsNotFull1(3)),   
									nsShouldInc3 = (nsNotFull1(3)),  
									ewShouldDec1 = 1,  
									noc[1].ewLockedlocal = false, 
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1) 
								=} 

							}

							else if (noc[1].ewLockedns) {

									tick {= noc[1].localPriority = nsNotFull(3),  
										noc[1].localLockedns = true,  
										ewShouldDec1 = nsNotFull1(3),  
										noc[1].ewLockedns = !nsNotFull(3), 
										nsShouldInc3 = nsNotFull1(3),  
										nsShouldDec1 = (nsNotEmpty1(1)) 
										//totalFlitsDelivered1 += nsNotEmpty1(1)
									=}

							}

							else {

								tick palt{
								//Local and EW both send to 2
								:(1/2):  {= noc[1].localPriority = nsNotFull(3),  
										noc[1].localLockedns = true,  
										ewShouldDec1 = nsNotFull1(3),  
										noc[1].ewLockedns = !nsNotFull(3), 
										nsShouldInc3 = nsNotFull1(3),  
										nsShouldDec1 = (nsNotEmpty1(1)) 
										//totalFlitsDelivered1 += nsNotEmpty1(1)
										=}			

								//Local Sends to 2,  EW to 0
								:(1/2):  {= noc[1].localLockedns = !nsNotFull(3), 
											noc[1].localPriority = !nsNotFull(3), 
											noc[1].localLen -= (nsNotFull1(3)),   
											nsShouldInc3 = (nsNotFull1(3)),  
											ewShouldDec1 = 1,  
											//totalFlitsDelivered1 += 1, 
											noc[1].nsPriority = nsNotEmpty(1) 
										=} 				

							}

						}

			}

			else if (noc[1].localLockedew) {


					if (noc[1].ewLockedlocal) {

							// Local Sens EW and EW sends local 
							tick {=  noc[1].localLockedew = !ewNotFull(0), 
										noc[1].localPriority = !ewNotFull(0), 
										noc[1].localLen -= (ewNotFull1(0)),   
										ewShouldInc0 = (ewNotFull1(0)),  
										noc[1].ewLockedlocal = !ewNotFull(0), 
										ewShouldDec1 = 1,  
										//totalFlitsDelivered1 += 1, 
										noc[1].nsPriority = nsNotEmpty(1) 
									=}  

						

					}
					else if (noc[1].ewLockedns) {

							//Local sends EW and EW sends NS
							tick {=  noc[1].localLockedew = !ewNotFull(0), 
										noc[1].localPriority = !ewNotFull(0) && nsNotFull(3), 
										noc[1].localLen -= (ewNotFull1(0)),   
										ewShouldInc0 = (ewNotFull1(0)),  
										ewShouldDec1 = nsNotFull1(3),  
										noc[1].ewLockedns = !nsNotFull(3), 
										nsShouldInc3 = nsNotFull1(3),  
										nsShouldDec1 = (nsNotEmpty1(1)),  
										//totalFlitsDelivered1 += nsNotEmpty1(1), 
										optimalRuns1 += ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
									=} 
	

					}
					else {

						tick palt{
				
					

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {= 		noc[1].localLockedew = !ewNotFull(0), 
										noc[1].localPriority = !ewNotFull(0), 
										noc[1].localLen -= (ewNotFull1(0)),   
										ewShouldInc0 = (ewNotFull1(0)),  
										noc[1].ewLockedlocal = !ewNotFull(0), 
										ewShouldDec1 = 1,  
										//totalFlitsDelivered1 += 1, 
										noc[1].nsPriority = nsNotEmpty(1) 
								=}

						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {= 		noc[1].localLockedew = !ewNotFull(0), 
										noc[1].localPriority = !ewNotFull(0) && nsNotFull(3), 
										noc[1].localLen -= (ewNotFull1(0)),   
										ewShouldInc0 = (ewNotFull1(0)),  
										ewShouldDec1 = nsNotFull1(3),  
										noc[1].ewLockedns = !nsNotFull(3), 
										nsShouldInc3 = nsNotFull1(3),  
										nsShouldDec1 = (nsNotEmpty1(1)),  
										//totalFlitsDelivered1 += nsNotEmpty1(1), 
										optimalRuns1 += ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
						=} 

					}
			}

			


			} 

			else {

				if (noc[1].ewLockedlocal) {

					tick palt {
						
						//Local sends NS and EW sends local
						:(1/3):  {= noc[1].localLockedns = localNotEmpty(1) && !nsNotFull(3), 
									noc[1].localPriority = localNotEmpty(1) && !nsNotFull(3), 
									noc[1].localLen -= (localNotEmpty1(1))*(nsNotFull1(3)),   
									nsShouldInc3 = (nsNotFull1(3))*(localNotEmpty1(1)),  
									ewShouldDec1 = 1,  
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1) 
								=} 

						// Local Sens EW and EW sends local 
						:(2/3):  {=  noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localPriority = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  
									ewShouldDec1 = 1,  
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1) 
								=}  

					}

				}
				else if (noc[1].ewLockedns) {

					tick palt {
						//Local sends NS and EW sends NS
						:(1/3):  {= noc[1].localPriority =localNotEmpty(1),  
									noc[1].localLockedns = localNotEmpty(1),  
									noc[1].ewLockedns = !nsNotFull(3), 
									ewShouldDec1 = nsNotFull1(3),  
									nsShouldInc3 = nsNotFull1(3),  
									nsShouldDec1 = (nsNotEmpty1(1))  
									//totalFlitsDelivered1 += nsNotEmpty1(1)
								=}
						//Local sends EW and EW sends NS
						:(2/3):  {=  noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localPriority = localNotEmpty(1) && !ewNotFull(0) && nsNotFull(3), 
									noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  
									ewShouldDec1 = nsNotFull1(3),  
									noc[1].ewLockedns = !nsNotFull(3), 
									nsShouldInc3 = nsNotFull1(3),  
									nsShouldDec1 = (nsNotEmpty1(1)),  
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									optimalRuns1 += localNotEmpty1(1)*ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
								=} 


					}

				}
				else {

					tick palt{
					//Local and EW both send to 2
					:(1/6):  {= 		noc[1].localPriority =localNotEmpty(1),  
									noc[1].localLockedns = localNotEmpty(1),  
									noc[1].ewLockedns = !nsNotFull(3), 
									ewShouldDec1 = nsNotFull1(3),  
									nsShouldInc3 = nsNotFull1(3),  
									nsShouldDec1 = (nsNotEmpty1(1))  
									//totalFlitsDelivered1 += nsNotEmpty1(1)
							=}			

					//Local Sends to 2,  EW to 0
					:(1/6):  {= 		noc[1].localLockedns = localNotEmpty(1) && !nsNotFull(3), 
									noc[1].localPriority = localNotEmpty(1) && !nsNotFull(3), 
									noc[1].localLen -= (localNotEmpty1(1))*(nsNotFull1(3)),   
									nsShouldInc3 = (nsNotFull1(3))*(localNotEmpty1(1)),  
									ewShouldDec1 = 1,  
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1) 
							=}					
				

					//Local has a 1 or 3 and EW has a 0
					:(1/3):  {= 		noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localPriority = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  
									ewShouldDec1 = 1,  
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1) 
							=}

					//Local has a 1 or 3 and EW has a 2
					:(1/3):  {= 		noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localPriority = localNotEmpty(1) && !ewNotFull(0) && nsNotFull(3), 
									noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  
									ewShouldDec1 = nsNotFull1(3),  
									noc[1].ewLockedns = !nsNotFull(3), 
									nsShouldInc3 = nsNotFull1(3),  
									nsShouldDec1 = (nsNotEmpty1(1)),  
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									optimalRuns1 += localNotEmpty1(1)*ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
					=} 

				}
		}

		}

	}


	else if ((noc[1].localPriority == false) && (noc[1].nsPriority == true)) {

		if(noc[1].localLockedns) {

			if(noc[1].ewLockedns) {

				tick {= noc[1].localPriority = nsNotFull(3),  
					noc[1].ewLockedns = !nsNotFull(3), 
					ewShouldDec1 = nsNotFull1(3),  
					nsShouldInc3 = nsNotFull1(3),  
					nsShouldDec1 = (nsNotEmpty1(1)), 
					//totalFlitsDelivered1 += nsNotEmpty1(1), 
					noc[1].nsPriority = nsNotFull(3)
				=} 


			}
			//Logically determined that ew cannot be locked local
			else {

			tick palt {	//Local and EW both send to 2
			:(1/2):  {= noc[1].localPriority = nsNotFull(3),  
					noc[1].ewLockedns = !nsNotFull(3), 
					ewShouldDec1 = nsNotFull1(3),  
					nsShouldInc3 = nsNotFull1(3),  
					nsShouldDec1 = (nsNotEmpty1(1)), 
					//totalFlitsDelivered1 += nsNotEmpty1(1), 
					noc[1].nsPriority = nsNotFull(3)
					=}
					//Local Sends to 2,  EW to 0
			:(1/2):  {= noc[1].localPriority = !nsNotFull(3), 
						noc[1].localLockedns = !nsNotFull(3), 
						noc[1].localLen -= nsNotFull1(3),   
						nsShouldInc3 = (nsNotFull1(3)),  
						ewShouldDec1 = nsNotEmpty0(1), 
						noc[1].ewLockedns = nsNotEmpty(1), 
						nsShouldDec1 = nsNotEmpty1(1),  
						//totalFlitsDelivered1 += 1, 
						noc[1].nsPriority = !nsNotEmpty(1)
				
					=}	
			}
			}



		}

		else if(noc[1].localLockedew) {

			if (noc[1].ewLockedns) {

						//Local sends EW and EW sends NS
						tick {=  noc[1].localPriority = !ewNotFull(0) && nsNotFull(3), 
									noc[1].localLockedew = !ewNotFull(0), 
									noc[1].localLen -= (ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0)),  
									noc[1].ewLockedns = !nsNotFull(3), 
									ewShouldDec1 = nsNotFull1(3),  
									nsShouldInc3 = nsNotFull1(3),  
									nsShouldDec1 = (nsNotEmpty1(1)),  
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									noc[1].nsPriority = nsNotFull(3), 
									optimalRuns1 += ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
								=} 


					

				}
			else {
				
					tick palt {				
				

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {=  noc[1].localPriority = !ewNotFull(0) && !nsNotEmpty(1),  
									noc[1].localLockedew = !ewNotFull(0), 
									noc[1].localLen -= (ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0)),  
									nsShouldDec1 = nsNotEmpty1(1), 
									noc[1].nsPriority = !nsNotEmpty(1),  
									ewShouldDec1 = nsNotEmpty0(1),  
									noc[1].ewLockedlocal = nsNotEmpty(1) 
									//totalFlitsDelivered1 += 1
								=}	

						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {= noc[1].localPriority = !ewNotFull(0) && nsNotFull(3), 
									noc[1].localLockedew = !ewNotFull(0), 
									noc[1].localLen -= (ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0)),  
									noc[1].ewLockedns = !nsNotFull(3), 
									ewShouldDec1 = nsNotFull1(3),  
									nsShouldInc3 = nsNotFull1(3),  
									nsShouldDec1 = (nsNotEmpty1(1)),  
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									noc[1].nsPriority = nsNotFull(3), 
									optimalRuns1 += ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
								=}  


					}
				}

		}


		else {
		
			 if (noc[1].ewLockedns) {

					tick palt {
						//Local sends NS and EW sends NS
						:(1/3):  tick {= noc[1].localPriority = localNotEmpty(1) && nsNotFull(3), 
									noc[1].localLockedns = localNotEmpty(1), 
									noc[1].ewLockedns = !nsNotFull(3), 
									ewShouldDec1 = nsNotFull1(3),  
									nsShouldInc3 = nsNotFull1(3),  
									nsShouldDec1 = (nsNotEmpty1(1)), 
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									noc[1].nsPriority = nsNotFull(3)
								=} 
						//Local sends EW and EW sends NS
						:(2/3):  {=  noc[1].localPriority = localNotEmpty(1) && !ewNotFull(0) && nsNotFull(3), 
									noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  
									noc[1].ewLockedns = !nsNotFull(3), 
									ewShouldDec1 = nsNotFull1(3),  
									nsShouldInc3 = nsNotFull1(3),  
									nsShouldDec1 = (nsNotEmpty1(1)),  
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									noc[1].nsPriority = nsNotFull(3), 
									optimalRuns1 += localNotEmpty1(1)*ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
								=} 


					}

				}
			else {
				
					tick palt {
						//Local and EW both send to 2
						:(1/6):  {= noc[1].localPriority = localNotEmpty(1) && nsNotFull(3), 
									noc[1].localLockedns = localNotEmpty(1), 
									noc[1].ewLockedns = !nsNotFull(3), 
									ewShouldDec1 = nsNotFull1(3),  
									nsShouldInc3 = nsNotFull1(3),  
									nsShouldDec1 = (nsNotEmpty1(1)), 
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									noc[1].nsPriority = nsNotFull(3)
								=}			
						//Local Sends to 2,  EW to 0
						:(1/6):  {= noc[1].localPriority = !nsNotFull(3) && localNotEmpty(1) && !nsNotEmpty(1),  
									noc[1].localLockedns = localNotEmpty(1) && !nsNotFull(3), 
									noc[1].localLen -= (localNotEmpty1(1))*(nsNotFull1(3)),   
									nsShouldInc3 = (nsNotFull1(3))*(localNotEmpty1(1)),  
									ewShouldDec1 = nsNotEmpty0(1), 
									noc[1].ewLockedlocal = nsNotEmpty(1), 
									nsShouldDec1 = nsNotEmpty1(1),  
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = !nsNotEmpty(1) 
								=}					
				

						//Local has a 1 or 3 and EW has a 0
						:(1/3):  {=  noc[1].localPriority = !ewNotFull(0) && localNotEmpty(1) && !nsNotEmpty(1),  
									noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  
									nsShouldDec1 = nsNotEmpty1(1), 
									noc[1].nsPriority = !nsNotEmpty(1),  
									ewShouldDec1 = nsNotEmpty0(1), 
									noc[1].ewLockedlocal = nsNotEmpty(1) 
									//totalFlitsDelivered1 += 1
								=}	

						//Local has a 1 or 3 and EW has a 2
						:(1/3):  {= noc[1].localPriority = localNotEmpty(1) && !ewNotFull(0) && nsNotFull(3), 
									noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  
									noc[1].ewLockedns = !nsNotFull(3), 
									ewShouldDec1 = nsNotFull1(3),  
									nsShouldInc3 = nsNotFull1(3),  
									nsShouldDec1 = (nsNotEmpty1(1)),  
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									noc[1].nsPriority = nsNotFull(3), 
									optimalRuns1 += localNotEmpty1(1)*ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
								=}  


					}
				}

		}

	}
	else {   //Localpriority == true && nsPriority == false

		if(noc[1].localLockedns) {

			if (noc[1].ewLockedlocal) {


						 //Local sends NS and EW sends local
								tick {= noc[1].localPriority = true,  
									noc[1].localLockedns = !nsNotFull(3),  
									noc[1].localLen -= (nsNotFull1(3)), 
									nsShouldInc3 = (nsNotFull1(3)),  
									ewShouldDec1 = 1,  
									noc[1].ewLockedlocal = false, 
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1) 
								=} 

				}

				else if(noc[1].ewLockedns) {

							tick {= noc[1].localPriority = !nsNotFull(3),  
									noc[1].localLockedns = !nsNotFull(3),  
									noc[1].localLen -= (nsNotFull1(3)),   
									nsShouldInc3 = (nsNotFull1(3)),  
									noc[1].ewLockedns = true, 
									nsShouldDec1 = (nsNotEmpty1(1)),  
									noc[1].nsPriority = false 
									//totalFlitsDelivered1 += nsNotEmpty1(1)
								=}	


				}


				else {


					tick palt {
						//Local and EW both send to 2
						:(1/2):  {= 	noc[1].localPriority = !nsNotFull(3),  
									noc[1].localLockedns = !nsNotFull(3),  
									noc[1].localLen -= (nsNotFull1(3)),   
									nsShouldInc3 = (nsNotFull1(3)),  
									noc[1].ewLockedns = true, 
									nsShouldDec1 = (nsNotEmpty1(1)),  
									noc[1].nsPriority = false 
									//totalFlitsDelivered1 += nsNotEmpty1(1)
								=}	
						//Local Sends to 2,  EW to 0
						:(1/2):  {= noc[1].localPriority = true,  
									noc[1].localLockedns = !nsNotFull(3),  
									noc[1].localLen -= (nsNotFull1(3)), 
									nsShouldInc3 = (nsNotFull1(3)),  
									ewShouldDec1 = 1,  
									noc[1].ewLockedlocal = false, 
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1) 
								=}					


					}
				}

		}

		else if(noc[1].localLockedew) {

			if (noc[1].ewLockedlocal) {

						// Local Sends EW and EW sends local
					tick {= 	noc[1].localPriority = true,  
						noc[1].localLockedew = !ewNotFull(0), 
						noc[1].localLen -= (ewNotFull1(0)),   
						ewShouldInc0 = (ewNotFull1(0)),  
						ewShouldDec1 = 1,  
						noc[1].ewLockedlocal = false, 
						//totalFlitsDelivered1 += 1, 
						noc[1].nsPriority = nsNotEmpty(1) 
					=}  

					

				}

				else if(noc[1].ewLockedns) {

	
								//Local has a 1 or 3 and EW has a 2
						tick {=  		noc[1].localPriority = !(ewNotFull(0) && !nsNotFull(3)),  
									noc[1].localLockedew = !ewNotFull(0), 
									noc[1].localLen -= (ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0)),  
									ewShouldDec1 = (nsNotFull1(3)),  
									noc[1].ewLockedlocal = !nsNotFull(3), 
									nsShouldInc3 = (nsNotFull1(3)),  
									nsShouldDec1 = (nsNotEmpty1(1)),  
									noc[1].nsPriority = false, 
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									optimalRuns1 += ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
								=}  


				}


				else {


					tick palt {				
				

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {= 	noc[1].localPriority = true,  
									noc[1].localLockedew = !ewNotFull(0), 
									noc[1].localLen -= (ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0)),  
									ewShouldDec1 = 1,  
									noc[1].ewLockedlocal = false, 
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1)
								=} 			
						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {=  noc[1].localPriority = !(ewNotFull(0) && !nsNotFull(3)),  
									noc[1].localLockedew = !ewNotFull(0), 
									noc[1].localLen -= (ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0)),  
									ewShouldDec1 = (nsNotFull1(3)),  
									noc[1].ewLockedlocal = !nsNotFull(3), 
									nsShouldInc3 = (nsNotFull1(3)),  
									nsShouldDec1 = (nsNotEmpty1(1)),  
									noc[1].nsPriority = false, 
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									optimalRuns1 += ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
								=}  


					}
				}


		}
		

		else {
			 if (noc[1].ewLockedlocal) {

					tick palt {
						 //Local sends NS and EW sends local
						:(1/3):  tick {= noc[1].localPriority = true,  
									noc[1].localLockedns = localNotEmpty(1) && !nsNotFull(3),  
									noc[1].localLen -= (nsNotFull1(3))*(localNotEmpty1(1)), 
									nsShouldInc3 = (nsNotFull1(3))*(localNotEmpty1(1)),  
									ewShouldDec1 = 1, 
									noc[1].ewLockedlocal = false,  
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1) 
								=} 
						// Local Sends EW and EW sends local
						:(2/3):  tick {= noc[1].localPriority = true,  
									noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  
									ewShouldDec1 = 1,  
									noc[1].ewLockedlocal = false, 
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1) 
								=}  

					}

				}

				else if(noc[1].ewLockedns) {


						tick palt {
						//Local and EW both send to 2
						:(1/3):  {= noc[1].localPriority = (localNotEmpty(1) && !nsNotFull(3)) || (!localNotEmpty(1) && nsNotFull(3)),  
									noc[1].localLockedns = localNotEmpty(1) && !nsNotFull(3),  
									noc[1].localLen -= (localNotEmpty1(1))*(nsNotFull1(3)),   
									nsShouldInc3 = (nsNotFull1(3)),  
									noc[1].ewLockedns = localNotEmpty(1) || (!localNotEmpty(1) && !nsNotFull(3)), 
									ewShouldDec1 = localNotEmpty0(1)*nsNotFull1(3), 
									nsShouldDec1 = (nsNotEmpty1(1)),  
									noc[1].nsPriority = false 
									//totalFlitsDelivered1 += nsNotEmpty1(1)
								=}	
								//Local has a 1 or 3 and EW has a 2
						:(2/3):  {=  noc[1].localPriority = (!ewNotFull(0) && localNotEmpty(1)) || (!localNotEmpty(1) && nsNotFull(3)) || (ewNotFull(0) && localNotEmpty(1) && nsNotFull(3)),  
									noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  
									ewShouldDec1 = (nsNotFull1(3)),  
									noc[1].ewLockedns = !nsNotFull(3), 
									nsShouldInc3 = (nsNotFull1(3)),  
									nsShouldDec1 = (nsNotEmpty1(1)),  
									noc[1].nsPriority = false, 
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									optimalRuns1 += ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
								=}  
						}


				}


				else {


					tick palt {
						//Local and EW both send to 2
						:(1/6):  {= noc[1].localPriority = (localNotEmpty(1) && !nsNotFull(3)) || (!localNotEmpty(1) && nsNotFull(3)),  
									noc[1].localLockedns = localNotEmpty(1) && !nsNotFull(3),  
									noc[1].localLen -= (localNotEmpty1(1))*(nsNotFull1(3)),   
									nsShouldInc3 = (nsNotFull1(3)),  
									noc[1].ewLockedns = localNotEmpty(1) || (!localNotEmpty(1) && !nsNotFull(3)), 
									ewShouldDec1 = localNotEmpty0(1)*nsNotFull1(3), 
									nsShouldDec1 = (nsNotEmpty1(1)),  
									noc[1].nsPriority = false 
									//totalFlitsDelivered1 += nsNotEmpty1(1)
								=}	
						//Local Sends to 2,  EW to 0
						:(1/6):  {= noc[1].localPriority = true,  
									noc[1].localLockedns = localNotEmpty(1) && !nsNotFull(3),  
									noc[1].localLen -= (nsNotFull1(3))*(localNotEmpty1(1)), 
									nsShouldInc3 = (nsNotFull1(3))*(localNotEmpty1(1)),  
									ewShouldDec1 = 1, 
									noc[1].ewLockedlocal = false,  
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1) 
								=}					
				

						//Local has a 1 or 3 and EW has a 0
						:(1/3):  {= noc[1].localPriority = true,  
									noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  
									ewShouldDec1 = 1,  
									noc[1].ewLockedlocal = false, 
									//totalFlitsDelivered1 += 1, 
									noc[1].nsPriority = nsNotEmpty(1) 
								=} 			
						//Local has a 1 or 3 and EW has a 2
						:(1/3):  {=  noc[1].localPriority = (!ewNotFull(0) && localNotEmpty(1)) || (!localNotEmpty(1) && nsNotFull(3)) || (ewNotFull(0) && localNotEmpty(1) && nsNotFull(3)),  
									noc[1].localLockedew = localNotEmpty(1) && !ewNotFull(0), 
									noc[1].localLen -= (localNotEmpty1(1))*(ewNotFull1(0)),   
									ewShouldInc0 = (ewNotFull1(0))*(localNotEmpty1(1)),  
									ewShouldDec1 = (nsNotFull1(3)),  
									noc[1].ewLockedns = !nsNotFull(3), 
									nsShouldInc3 = (nsNotFull1(3)),  
									nsShouldDec1 = (nsNotEmpty1(1)),  
									noc[1].nsPriority = false, 
									//totalFlitsDelivered1 += nsNotEmpty1(1), 
									optimalRuns1 += ewNotFull1(0)*nsNotFull1(3)*nsNotEmpty1(1)
								=}  


					}
				}
		}


	}





}

process arbiter2(){

	//tick {=  localNotEmptyOne = (noc[2].localLen > 0) ? 1 : 0 =};

	if (noc[2].ewLen == 0) {		//If the EW buffer of the NoC is empty

		if (noc[2].localLockedns == true) {		//If the local buffer is locked sending NS

			tick {=  noc[2].localLockedns = !nsNotFull(0),   //Sets the priority to false if it was able to send to the ns buffer of the NoC in the y direction
				noc[2].localPriority = !nsNotFull(0) || noc[2].localPriority, 		//Local gets priority if it is unable to send
				noc[2].localLen -= nsNotFull1(0),      //Local sends a flit ns if the receiving buffer is not full
				nsShouldInc0 = (nsNotFull1(0)),   //The ns direction receives the flit if it is not already full
				nsShouldDec2 = (nsNotEmpty1(2)) 						//The ns buffer sends a flit to local if it is not empty
				//totalFlitsDelivered2 += nsNotEmpty1(2)
			=}

		}

		else if (noc[2].localLockedew) {

			tick {=   			noc[2].localLockedew = !ewNotFull(3),  // Local is locked it if has a flit and is unable to send it
							noc[2].localPriority = !ewNotFull(3) || noc[2].localPriority,   // Local gets priority under the same conditions		
							noc[2].localLen -= (ewNotFull1(3)),   //Local sends a flit to the ew direction if it is not empty and the receiving buffer is not full
							ewShouldInc3 = (ewNotFull1(3)),  //The ew direction receives it under the same conditions
							nsShouldDec2 = (nsNotEmpty1(2))  //The ns buffer sends a flit to local if it is not empty
							//totalFlitsDelivered2 += nsNotEmpty1(2)	
							
			=}


		} 

		else {
			tick palt {
				//Local sends in the NS direction
				:(1/3): {=   noc[2].localLockedns = localNotEmpty(2) && !nsNotFull(0),  // Local is locked it if has a flit and is unable to send it
							noc[2].localPriority = (localNotEmpty(2) && !nsNotFull(0)) || noc[2].localPriority,   // Local gets priority under the same conditions
							noc[2].localLen -= (localNotEmpty1(2))*(nsNotFull1(0)),   //Local sends a flit to the ns direction if it is not empty and the receiving buffer is not full
					   		nsShouldInc0 = (nsNotFull1(0))*(localNotEmpty1(2)),  //The ns direction receives the flit under the same conditions
							nsShouldDec2 = (nsNotEmpty1(2))    //The ns buffer sends a flit to local if it is not empty	
							//totalFlitsDelivered2 += nsNotEmpty1(2)
						=}
				//Local sends to the ew direction
				:(2/3): {=   noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3),  // Local is locked it if has a flit and is unable to send it
							noc[2].localPriority = (localNotEmpty(2) && !ewNotFull(3)) || noc[2].localPriority,   // Local gets priority under the same conditions
							noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   //Local sends a flit to the ew direction if it is not empty and the receiving buffer is not full
							ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  //The ew direction receives it under the same conditions
							nsShouldDec2 = (nsNotEmpty1(2))  //The ns buffer sends a flit to local if it is not empty
							//totalFlitsDelivered2 += nsNotEmpty1(2)
							
						=}
			}
		}

	}
	else if ((noc[2].localPriority == true) && (noc[2].nsPriority == true)) {

		if (noc[2].localLockedns == true) {

			if (noc[2].ewLockedns) {

				tick {=  noc[2].localLockedns = !nsNotFull(0),  	//Local stays locked if it is unable to send
					noc[2].localPriority = !nsNotFull(0), 
						noc[2].localLen -= nsNotFull1(0),   //Local sends if the ns direction is not already full
						nsShouldInc0 = nsNotFull1(0),  //The ns direction receives under the same conditions
						noc[2].nsPriority = false, 
						noc[2].ewLockedns = true,  
						nsShouldDec2 = (nsNotEmpty1(2))    //The ns buffer sends a flit to local if it is not empty 
						//totalFlitsDelivered2 += nsNotEmpty1(2)
				=}

			}

			else {
			tick palt {
			// Local and EW both send ns	
			:(1/2):  {=  noc[2].localLockedns = !nsNotFull(0),  	//Local stays locked if it is unable to send
						noc[2].localLen -= nsNotFull1(0),   //Local sends if the ns direction is not already full
						nsShouldInc0 = nsNotFull1(0),  //The ns direction receives under the same conditions
						nsShouldDec2 = (nsNotEmpty1(2)),    //The ns buffer sends a flit to local if it is not empty
						noc[2].nsPriority = false, 
						//totalFlitsDelivered2 += nsNotEmpty1(2), 
						noc[2].ewLockedns = true,  			//The Ew buffer is locked to send in the ns direction
						noc[2].localPriority = !nsNotFull(0) //Local remains in priority if it did not send
					=}  
			 
			 //Local sends ns,  and EW sends to to local
			:(1/2):  {=  noc[2].localLockedns =  !nsNotFull(0),   //Local stays locked if it is unable to send
						noc[2].localPriority = !(nsNotFull(0) && nsNotEmpty(2)),  //Local only loses priority if it sends and ew doesn't
						noc[2].localLen -= (nsNotFull1(0)),   //Local sends ns if it isn't empty and ns isn't full
						nsShouldInc0 = (nsNotFull1(0)),  //Ns receives under the same conditions
						ewShouldDec2 = nsNotEmpty0(2),  	//Ew sends if the ns buffer is empty
				
						noc[2].ewLockedlocal = nsNotEmpty(2),  	//Local is locked if the ns buffer is not empty
						noc[2].nsPriority = !nsNotEmpty(2),      //NS loses priority if it sends
						nsShouldDec2 = (nsNotEmpty1(2))  		//Ns sends local if it isn't empty
						//totalFlitsDelivered2 += nsNotEmpty1(2)
					=}    
			}
		}

		}

		else if (noc[2].localLockedew) {

			if(noc[2].ewLockedns) {	

				//Local has a 1 or 3 and EW has a 2
				tick {=  noc[2].localLockedew = !ewNotFull(3),  //Local is locked in the ew direction if it is unable to send
							noc[2].localPriority = !(!ewNotFull(3) && nsNotFull(0)),  //Local remains in priority under the same conditions
							noc[2].localLen -= (ewNotFull1(3)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc3 = (ewNotFull1(3)),  //The ew direction recieves under the same conditions
							ewShouldDec2 = (nsNotFull1(0)),   // Ew sends if the ns direction is not full
							noc[2].ewLockedns = !nsNotFull(0),  // Ew is locked to ns if it is unable to send
							nsShouldInc0 = (nsNotFull1(0)),  //The ns direction receives if it is not full
							noc[2].nsPriority = nsNotFull(0),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec2 = (nsNotEmpty1(2)),  // Ns sends if it is not empty
							//totalFlitsDelivered2 += nsNotEmpty1(2), 
							optimalRuns2 += ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)

				=} 


			}

			else {

				tick palt { 

				//Local has a 1 or 3 and EW has a 0	
				:(1/2):  {=  noc[2].localLockedew = !ewNotFull(3),  //Local is locked in the ew direction if it is unable to send
							noc[2].localPriority = !(ewNotFull(3) && nsNotEmpty(2)),  //Local remains in priority under the same conditions
							noc[2].localLen -= (ewNotFull1(3)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc3 = (ewNotFull1(3)),  //The ew direction receives under the same conditions
							noc[2].ewLockedlocal = nsNotEmpty(2),  //The ew buffer is locked into the local direction if the ns buffer is not empty
							noc[2].nsPriority = !nsNotEmpty(2),   //The ns buffer remains in priority if it is empty
							nsShouldDec2 = (nsNotEmpty1(2)), 	//Ns sneds if it is not empty
							ewShouldDec2 = nsNotEmpty0(2) 		//Ew sends if 
							//totalFlitsDelivered2 += 1
				=}	

				//Local has a 1 or 3 and EW has a 2
				:(1/2):  {=  noc[2].localLockedew = !ewNotFull(3),  //Local is locked in the ew direction if it is unable to send
							noc[2].localPriority = !(!ewNotFull(3) && nsNotFull(0)),  //Local remains in priority under the same conditions
							noc[2].localLen -= (ewNotFull1(3)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc3 = (ewNotFull1(3)),  //The ew direction recieves under the same conditions
							ewShouldDec2 = (nsNotFull1(0)),   // Ew sends if the ns direction is not full
							noc[2].ewLockedns = !nsNotFull(0),  // Ew is locked to ns if it is unable to send
							nsShouldInc0 = (nsNotFull1(0)),  //The ns direction receives if it is not full
							noc[2].nsPriority = nsNotFull(0),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec2 = (nsNotEmpty1(2)),  // Ns sends if it is not empty
							//totalFlitsDelivered2 += nsNotEmpty1(2), 
							optimalRuns2 += ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
				=} 


				}	
			}

		}

		

		else{

			if(noc[2].ewLockedns) {

				tick palt { 
				//Local and EW both send to 2	
				:(1/3): {= 	noc[2].ewLockedns = (localNotEmpty(2)) || (!localNotEmpty(2) && nsNotFull(0)),                 //The ew buffer gets locked in the ns direction if local is not empty 
							noc[2].localPriority = (localNotEmpty(2) && !nsNotFull(0)) || (!localNotEmpty(2) && nsNotFull(0)),    //Local remains in priority if it is non-empty and is unable to send
							noc[2].localLockedns = (localNotEmpty(2) && !nsNotFull(0)),  // Local gets locked to ns under the same conditions
							noc[2].localLen -= (localNotEmpty1(2))*(nsNotFull1(0)),   	//Local sends the ns direction if it is not empty,  and the receiving buffer is not full
							nsShouldInc0 = (nsNotFull1(0)),    //The ns direction receives if it is not full (either from ew or local)
							ewShouldDec2 = localNotEmpty0(2)*(nsNotFull1(0)), 		//Ew sends if local is empty and the ns direction is not full
							nsShouldDec2 = (nsNotEmpty1(2)),  		//Ns sends local if it is not empty
							noc[2].nsPriority = !localNotEmpty(2) && nsNotFull(0)
							//totalFlitsDelivered2 += nsNotEmpty1(2)
						=}		

				//Local has a 1 or 3 and EW has a 2
				:(2/3):  {=  noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3),  //Local is locked in the ew direction if it is unable to send
							noc[2].localPriority = (localNotEmpty(2) && !ewNotFull(3)) || (!localNotEmpty(2) && nsNotFull(0)) || ( (localNotEmpty(2) && ewNotFull(3) && (nsNotFull(0)))),  //Local remains in priority under the same conditions
							noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  //The ew direction recieves under the same conditions
							ewShouldDec2 = (nsNotFull1(0)),   // Ew sends if the ns direction is not full
							noc[2].ewLockedns = !nsNotFull(0),  // Ew is locked to ns if it is unable to send
							nsShouldInc0 = (nsNotFull1(0)),  //The ns direction receives if it is not full
							noc[2].nsPriority = nsNotFull(0),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec2 = (nsNotEmpty1(2)),  // Ns sends if it is not empty
							//totalFlitsDelivered2 += nsNotEmpty1(2), 
							optimalRuns2 += localNotEmpty1(2)*ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
				=} 


				}	


			}

			else {

				tick palt { 
				//Local and EW both send to 2	
				:(1/6):  {=  noc[2].ewLockedns = (localNotEmpty(2)) || (!localNotEmpty(2) && nsNotFull(0)),                 //The ew buffer gets locked in the ns direction if local is not empty 
							noc[2].localPriority = (localNotEmpty(2) && !nsNotFull(0)) || (!localNotEmpty(2) && nsNotFull(0)),    //Local remains in priority if it is non-empty and is unable to send
							noc[2].localLockedns = (localNotEmpty(2) && !nsNotFull(0)),  // Local gets locked to ns under the same conditions
							noc[2].localLen -= (localNotEmpty1(2))*(nsNotFull1(0)),   	//Local sends the ns direction if it is not empty,  and the receiving buffer is not full
							nsShouldInc0 = (nsNotFull1(0)),    //The ns direction receives if it is not full (either from ew or local)
							ewShouldDec2 = localNotEmpty0(2)*(nsNotFull1(0)), 		//Ew sends if local is empty and the ns direction is not full
							nsShouldDec2 = (nsNotEmpty1(2)),  		//Ns sends local if it is not empty
							noc[2].nsPriority = !localNotEmpty(2) && nsNotFull(0)
							//totalFlitsDelivered2 += nsNotEmpty1(2)
						=}	

				//Local Sends to 2,  EW to 0
				:(1/6):  {=  noc[2].localLockedns = localNotEmpty(2) && !nsNotFull(0),  //Local is locked in the ns direction if it is unable to send
							noc[2].localPriority = (localNotEmpty(2) && !nsNotFull(0)) || (localNotEmpty(2) && !nsNotEmpty(2)) || ( ( (localNotEmpty(2)) && (nsNotFull(0)) ) && !nsNotEmpty(2)),  //Local remains in priority under the same conditions
							noc[2].localLen -= (localNotEmpty1(2))*(nsNotFull1(0)),   //Local sends the ns direction if it is not empty,  and the receiving buffer is not full
							nsShouldInc0 = (nsNotFull1(0))*(localNotEmpty1(2)),  //The ns direction receives if it is not full and local is not empty
							ewShouldDec2 = nsNotEmpty0(2),  //Ew sends local if the ns buffer is empty
							noc[2].ewLockedlocal = nsNotEmpty(2),  //Ew gets locked to local if the ns buffer is not empty
							noc[2].nsPriority = !nsNotEmpty(2),  //Ns remains in priority if it is empty
							nsShouldDec2 = (nsNotEmpty1(2))    // Ns sends if it is not empty
							//totalFlitsDelivered2 += 1
						=}					
				

				//Local has a 1 or 3 and EW has a 0	
				:(1/3):  {=  noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3),  //Local is locked in the ew direction if it is unable to send
							noc[2].localPriority = (localNotEmpty(2) && !ewNotFull(3)) || (localNotEmpty(2) && !nsNotEmpty(2)) || ( ( (localNotEmpty(2)) && (ewNotFull(3)) ) && !nsNotEmpty(2)),  //Local remains in priority under the same conditions
							noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  //The ew direction receives under the same conditions
							noc[2].ewLockedlocal = nsNotEmpty(2),  //The ew buffer is locked into the local direction if the ns buffer is not empty
							noc[2].nsPriority = !nsNotEmpty(2),   //The ns buffer remains in priority if it is empty
							nsShouldDec2 = (nsNotEmpty1(2)), 	//Ns sneds if it is not empty
							ewShouldDec2 = nsNotEmpty0(2) 		//Ew sends if 
							//totalFlitsDelivered2 += 1
				=}	

				//Local has a 1 or 3 and EW has a 2
				:(1/3):  {=  noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3),  //Local is locked in the ew direction if it is unable to send
							noc[2].localPriority = (localNotEmpty(2) && !ewNotFull(3)) || (!localNotEmpty(2) && nsNotFull(0)) || ( (localNotEmpty(2) && ewNotFull(3) && (nsNotFull(0)))),  //Local remains in priority under the same conditions
							noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  //The ew direction recieves under the same conditions
							ewShouldDec2 = (nsNotFull1(0)),   // Ew sends if the ns direction is not full
							noc[2].ewLockedns = !nsNotFull(0),  // Ew is locked to ns if it is unable to send
							nsShouldInc0 = (nsNotFull1(0)),  //The ns direction receives if it is not full
							noc[2].nsPriority = nsNotFull(0),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec2 = (nsNotEmpty1(2)),  // Ns sends if it is not empty
							//totalFlitsDelivered2 += nsNotEmpty1(2), 
							optimalRuns2 += localNotEmpty1(2)*ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
				=} 


				}	
			}
		}



	}

	else if ((noc[2].localPriority == false) && (noc[2].nsPriority == false)) {

			if(noc[2].localLockedns) {

							if (noc[2].ewLockedlocal) {
								tick {=  noc[2].localLockedns = !nsNotFull(0), 
									noc[2].localPriority = !nsNotFull(0), 
									noc[2].localLen -= (nsNotFull1(0)),   
									nsShouldInc0 = (nsNotFull1(0)),  
									ewShouldDec2 = 1,  
									noc[2].ewLockedlocal = false, 
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2) 
								=} 

							}

							else if (noc[2].ewLockedns) {

									tick {=  noc[2].localPriority = nsNotFull(0),  
										noc[2].localLockedns = true,  
										ewShouldDec2 = nsNotFull1(0),  
										noc[2].ewLockedns = !nsNotFull(0), 
										nsShouldInc0 = nsNotFull1(0),  
										nsShouldDec2 = (nsNotEmpty1(2)) 
										//totalFlitsDelivered2 += nsNotEmpty1(2)
									=}

							}

							else {

								tick palt{
								//Local and EW both send to 2
								:(1/2):  {=  noc[2].localPriority = nsNotFull(0),  
										noc[2].localLockedns = true,  
										ewShouldDec2 = nsNotFull1(0),  
										noc[2].ewLockedns = !nsNotFull(0), 
										nsShouldInc0 = nsNotFull1(0),  
										nsShouldDec2 = (nsNotEmpty1(2)) 
										//totalFlitsDelivered2 += nsNotEmpty1(2)
										=}			

								//Local Sends to 2,  EW to 0
								:(1/2):  {=  noc[2].localLockedns = !nsNotFull(0), 
											noc[2].localPriority = !nsNotFull(0), 
											noc[2].localLen -= (nsNotFull1(0)),   
											nsShouldInc0 = (nsNotFull1(0)),  
											ewShouldDec2 = 1,  
											//totalFlitsDelivered2 += 1, 
											noc[2].nsPriority = nsNotEmpty(2) 
										=} 				

							}

						}

			}

			else if (noc[2].localLockedew) {


					if (noc[2].ewLockedlocal) {

							// Local Sens EW and EW sends local 
							tick {=   noc[2].localLockedew = !ewNotFull(3), 
										noc[2].localPriority = !ewNotFull(3), 
										noc[2].localLen -= (ewNotFull1(3)),   
										ewShouldInc3 = (ewNotFull1(3)),  
										noc[2].ewLockedlocal = !ewNotFull(3), 
										ewShouldDec2 = 1,  
										//totalFlitsDelivered2 += 1, 
										noc[2].nsPriority = nsNotEmpty(2) 
									=}  

						

					}
					else if (noc[2].ewLockedns) {

							//Local sends EW and EW sends NS
							tick {=   noc[2].localLockedew = !ewNotFull(3), 
										noc[2].localPriority = !ewNotFull(3) && nsNotFull(0), 
										noc[2].localLen -= (ewNotFull1(3)),   
										ewShouldInc3 = (ewNotFull1(3)),  
										ewShouldDec2 = nsNotFull1(0),  
										noc[2].ewLockedns = !nsNotFull(0), 
										nsShouldInc0 = nsNotFull1(0),  
										nsShouldDec2 = (nsNotEmpty1(2)),  
										//totalFlitsDelivered2 += nsNotEmpty1(2), 
										optimalRuns2 += ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
									=} 
	

					}
					else {

						tick palt{
				
					

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {=  		noc[2].localLockedew = !ewNotFull(3), 
										noc[2].localPriority = !ewNotFull(3), 
										noc[2].localLen -= (ewNotFull1(3)),   
										ewShouldInc3 = (ewNotFull1(3)),  
										noc[2].ewLockedlocal = !ewNotFull(3), 
										ewShouldDec2 = 1,  
										//totalFlitsDelivered2 += 1, 
										noc[2].nsPriority = nsNotEmpty(2) 
								=}

						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {=  		noc[2].localLockedew = !ewNotFull(3), 
										noc[2].localPriority = !ewNotFull(3) && nsNotFull(0), 
										noc[2].localLen -= (ewNotFull1(3)),   
										ewShouldInc3 = (ewNotFull1(3)),  
										ewShouldDec2 = nsNotFull1(0),  
										noc[2].ewLockedns = !nsNotFull(0), 
										nsShouldInc0 = nsNotFull1(0),  
										nsShouldDec2 = (nsNotEmpty1(2)),  
										//totalFlitsDelivered2 += nsNotEmpty1(2), 
										optimalRuns2 += ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
						=} 

					}
			}

			


			} 

			else {

				if (noc[2].ewLockedlocal) {

					tick palt {
						
						//Local sends NS and EW sends local
						:(1/3):  {=  noc[2].localLockedns = localNotEmpty(2) && !nsNotFull(0), 
									noc[2].localPriority = localNotEmpty(2) && !nsNotFull(0), 
									noc[2].localLen -= (localNotEmpty1(2))*(nsNotFull1(0)),   
									nsShouldInc0 = (nsNotFull1(0))*(localNotEmpty1(2)),  
									ewShouldDec2 = 1,  
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2) 
								=} 

						// Local Sens EW and EW sends local 
						:(2/3):  {=   noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localPriority = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  
									ewShouldDec2 = 1,  
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2) 
								=}  

					}

				}
				else if (noc[2].ewLockedns) {

					tick palt {
						//Local sends NS and EW sends NS
						:(1/3):  {=  noc[2].localPriority =localNotEmpty(2),  
									noc[2].localLockedns = localNotEmpty(2),  
									noc[2].ewLockedns = !nsNotFull(0), 
									ewShouldDec2 = nsNotFull1(0),  
									nsShouldInc0 = nsNotFull1(0),  
									nsShouldDec2 = (nsNotEmpty1(2))  
									//totalFlitsDelivered2 += nsNotEmpty1(2)
								=}
						//Local sends EW and EW sends NS
						:(2/3):  {=   noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localPriority = localNotEmpty(2) && !ewNotFull(3) && nsNotFull(0), 
									noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  
									ewShouldDec2 = nsNotFull1(0),  
									noc[2].ewLockedns = !nsNotFull(0), 
									nsShouldInc0 = nsNotFull1(0),  
									nsShouldDec2 = (nsNotEmpty1(2)),  
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									optimalRuns2 += localNotEmpty1(2)*ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
								=} 


					}

				}
				else {

					tick palt{
					//Local and EW both send to 2
					:(1/6):  {=  		noc[2].localPriority =localNotEmpty(2),  
									noc[2].localLockedns = localNotEmpty(2),  
									noc[2].ewLockedns = !nsNotFull(0), 
									ewShouldDec2 = nsNotFull1(0),  
									nsShouldInc0 = nsNotFull1(0),  
									nsShouldDec2 = (nsNotEmpty1(2))  
									//totalFlitsDelivered2 += nsNotEmpty1(2)
							=}			

					//Local Sends to 2,  EW to 0
					:(1/6):  {=  		noc[2].localLockedns = localNotEmpty(2) && !nsNotFull(0), 
									noc[2].localPriority = localNotEmpty(2) && !nsNotFull(0), 
									noc[2].localLen -= (localNotEmpty1(2))*(nsNotFull1(0)),   
									nsShouldInc0 = (nsNotFull1(0))*(localNotEmpty1(2)),  
									ewShouldDec2 = 1,  
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2) 
							=}					
				

					//Local has a 1 or 3 and EW has a 0
					:(1/3):  {=  		noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localPriority = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  
									ewShouldDec2 = 1,  
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2) 
							=}

					//Local has a 1 or 3 and EW has a 2
					:(1/3):  {=  		noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localPriority = localNotEmpty(2) && !ewNotFull(3) && nsNotFull(0), 
									noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  
									ewShouldDec2 = nsNotFull1(0),  
									noc[2].ewLockedns = !nsNotFull(0), 
									nsShouldInc0 = nsNotFull1(0),  
									nsShouldDec2 = (nsNotEmpty1(2)),  
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									optimalRuns2 += localNotEmpty1(2)*ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
					=} 

				}
		}

		}

	}


	else if ((noc[2].localPriority == false) && (noc[2].nsPriority == true)) {

		if(noc[2].localLockedns) {

			if(noc[2].ewLockedns) {

				tick {=  noc[2].localPriority = nsNotFull(0),  
					noc[2].ewLockedns = !nsNotFull(0), 
					ewShouldDec2 = nsNotFull1(0),  
					nsShouldInc0 = nsNotFull1(0),  
					nsShouldDec2 = (nsNotEmpty1(2)), 
					//totalFlitsDelivered2 += nsNotEmpty1(2), 
					noc[2].nsPriority = nsNotFull(0)
				=} 


			}
			//Logically determined that ew cannot be locked local
			else {

			tick palt {	//Local and EW both send to 2
			:(1/2):  {=  noc[2].localPriority = nsNotFull(0),  
					noc[2].ewLockedns = !nsNotFull(0), 
					ewShouldDec2 = nsNotFull1(0),  
					nsShouldInc0 = nsNotFull1(0),  
					nsShouldDec2 = (nsNotEmpty1(2)), 
					//totalFlitsDelivered2 += nsNotEmpty1(2), 
					noc[2].nsPriority = nsNotFull(0)
					=}
					//Local Sends to 2,  EW to 0
			:(1/2):  {=  noc[2].localPriority = !nsNotFull(0), 
						noc[2].localLockedns = !nsNotFull(0), 
						noc[2].localLen -= nsNotFull1(0),   
						nsShouldInc0 = (nsNotFull1(0)),  
						ewShouldDec2 = nsNotEmpty0(2), 
						noc[2].ewLockedns = nsNotEmpty(2), 
						nsShouldDec2 = nsNotEmpty1(2),  
						//totalFlitsDelivered2 += 1, 
						noc[2].nsPriority = !nsNotEmpty(2)
				
					=}	
			}
			}



		}

		else if(noc[2].localLockedew) {

			if (noc[2].ewLockedns) {

						//Local sends EW and EW sends NS
						tick {=   noc[2].localPriority = !ewNotFull(3) && nsNotFull(0), 
									noc[2].localLockedew = !ewNotFull(3), 
									noc[2].localLen -= (ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3)),  
									noc[2].ewLockedns = !nsNotFull(0), 
									ewShouldDec2 = nsNotFull1(0),  
									nsShouldInc0 = nsNotFull1(0),  
									nsShouldDec2 = (nsNotEmpty1(2)),  
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									noc[2].nsPriority = nsNotFull(0), 
									optimalRuns2 += ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
								=} 


					

				}
			else {
				
					tick palt {				
				

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {=   noc[2].localPriority = !ewNotFull(3) && !nsNotEmpty(2),  
									noc[2].localLockedew = !ewNotFull(3), 
									noc[2].localLen -= (ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3)),  
									nsShouldDec2 = nsNotEmpty1(2), 
									noc[2].nsPriority = !nsNotEmpty(2),  
									ewShouldDec2 = nsNotEmpty0(2),  
									noc[2].ewLockedlocal = nsNotEmpty(2) 
									//totalFlitsDelivered2 += 1
								=}	

						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {=  noc[2].localPriority = !ewNotFull(3) && nsNotFull(0), 
									noc[2].localLockedew = !ewNotFull(3), 
									noc[2].localLen -= (ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3)),  
									noc[2].ewLockedns = !nsNotFull(0), 
									ewShouldDec2 = nsNotFull1(0),  
									nsShouldInc0 = nsNotFull1(0),  
									nsShouldDec2 = (nsNotEmpty1(2)),  
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									noc[2].nsPriority = nsNotFull(0), 
									optimalRuns2 += ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
								=}  


					}
				}

		}


		else {
		
			 if (noc[2].ewLockedns) {

					tick palt {
						//Local sends NS and EW sends NS
						:(1/3):  tick {=  noc[2].localPriority = localNotEmpty(2) && nsNotFull(0), 
									noc[2].localLockedns = localNotEmpty(2), 
									noc[2].ewLockedns = !nsNotFull(0), 
									ewShouldDec2 = nsNotFull1(0),  
									nsShouldInc0 = nsNotFull1(0),  
									nsShouldDec2 = (nsNotEmpty1(2)), 
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									noc[2].nsPriority = nsNotFull(0)
								=} 
						//Local sends EW and EW sends NS
						:(2/3):  {=   noc[2].localPriority = localNotEmpty(2) && !ewNotFull(3) && nsNotFull(0), 
									noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  
									noc[2].ewLockedns = !nsNotFull(0), 
									ewShouldDec2 = nsNotFull1(0),  
									nsShouldInc0 = nsNotFull1(0),  
									nsShouldDec2 = (nsNotEmpty1(2)),  
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									noc[2].nsPriority = nsNotFull(0), 
									optimalRuns2 += localNotEmpty1(2)*ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
								=} 


					}

				}
			else {
				
					tick palt {
						//Local and EW both send to 2
						:(1/6):  {=  noc[2].localPriority = localNotEmpty(2) && nsNotFull(0), 
									noc[2].localLockedns = localNotEmpty(2), 
									noc[2].ewLockedns = !nsNotFull(0), 
									ewShouldDec2 = nsNotFull1(0),  
									nsShouldInc0 = nsNotFull1(0),  
									nsShouldDec2 = (nsNotEmpty1(2)), 
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									noc[2].nsPriority = nsNotFull(0)
								=}			
						//Local Sends to 2,  EW to 0
						:(1/6):  {=  noc[2].localPriority = !nsNotFull(0) && localNotEmpty(2) && !nsNotEmpty(2),  
									noc[2].localLockedns = localNotEmpty(2) && !nsNotFull(0), 
									noc[2].localLen -= (localNotEmpty1(2))*(nsNotFull1(0)),   
									nsShouldInc0 = (nsNotFull1(0))*(localNotEmpty1(2)),  
									ewShouldDec2 = nsNotEmpty0(2), 
									noc[2].ewLockedlocal = nsNotEmpty(2), 
									nsShouldDec2 = nsNotEmpty1(2),  
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = !nsNotEmpty(2) 
								=}					
				

						//Local has a 1 or 3 and EW has a 0
						:(1/3):  {=   noc[2].localPriority = !ewNotFull(3) && localNotEmpty(2) && !nsNotEmpty(2),  
									noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  
									nsShouldDec2 = nsNotEmpty1(2), 
									noc[2].nsPriority = !nsNotEmpty(2),  
									ewShouldDec2 = nsNotEmpty0(2), 
									noc[2].ewLockedlocal = nsNotEmpty(2) 
									//totalFlitsDelivered2 += 1
								=}	

						//Local has a 1 or 3 and EW has a 2
						:(1/3):  {=  noc[2].localPriority = localNotEmpty(2) && !ewNotFull(3) && nsNotFull(0), 
									noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  
									noc[2].ewLockedns = !nsNotFull(0), 
									ewShouldDec2 = nsNotFull1(0),  
									nsShouldInc0 = nsNotFull1(0),  
									nsShouldDec2 = (nsNotEmpty1(2)),  
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									noc[2].nsPriority = nsNotFull(0), 
									optimalRuns2 += localNotEmpty1(2)*ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
								=}  


					}
				}

		}

	}
	else {   //Localpriority == true && nsPriority == false

		if(noc[2].localLockedns) {

			if (noc[2].ewLockedlocal) {


						 //Local sends NS and EW sends local
								tick {=  noc[2].localPriority = true,  
									noc[2].localLockedns = !nsNotFull(0),  
									noc[2].localLen -= (nsNotFull1(0)), 
									nsShouldInc0 = (nsNotFull1(0)),  
									ewShouldDec2 = 1,  
									noc[2].ewLockedlocal = false, 
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2) 
								=} 

				}

				else if(noc[2].ewLockedns) {

							tick {=  noc[2].localPriority = !nsNotFull(0),  
									noc[2].localLockedns = !nsNotFull(0),  
									noc[2].localLen -= (nsNotFull1(0)),   
									nsShouldInc0 = (nsNotFull1(0)),  
									noc[2].ewLockedns = true, 
									nsShouldDec2 = (nsNotEmpty1(2)),  
									noc[2].nsPriority = false 
									//totalFlitsDelivered2 += nsNotEmpty1(2)
								=}	


				}


				else {


					tick palt {
						//Local and EW both send to 2
						:(1/2):  {=  	noc[2].localPriority = !nsNotFull(0),  
									noc[2].localLockedns = !nsNotFull(0),  
									noc[2].localLen -= (nsNotFull1(0)),   
									nsShouldInc0 = (nsNotFull1(0)),  
									noc[2].ewLockedns = true, 
									nsShouldDec2 = (nsNotEmpty1(2)),  
									noc[2].nsPriority = false 
									//totalFlitsDelivered2 += nsNotEmpty1(2)
								=}	
						//Local Sends to 2,  EW to 0
						:(1/2):  {=  noc[2].localPriority = true,  
									noc[2].localLockedns = !nsNotFull(0),  
									noc[2].localLen -= (nsNotFull1(0)), 
									nsShouldInc0 = (nsNotFull1(0)),  
									ewShouldDec2 = 1,  
									noc[2].ewLockedlocal = false, 
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2) 
								=}					


					}
				}

		}

		else if(noc[2].localLockedew) {

			if (noc[2].ewLockedlocal) {

						// Local Sends EW and EW sends local
					tick {=  	noc[2].localPriority = true,  
						noc[2].localLockedew = !ewNotFull(3), 
						noc[2].localLen -= (ewNotFull1(3)),   
						ewShouldInc3 = (ewNotFull1(3)),  
						ewShouldDec2 = 1,  
						noc[2].ewLockedlocal = false, 
						//totalFlitsDelivered2 += 1, 
						noc[2].nsPriority = nsNotEmpty(2) 
					=}  

					

				}

				else if(noc[2].ewLockedns) {

	
								//Local has a 1 or 3 and EW has a 2
						tick {=   		noc[2].localPriority = !(ewNotFull(3) && !nsNotFull(0)),  
									noc[2].localLockedew = !ewNotFull(3), 
									noc[2].localLen -= (ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3)),  
									ewShouldDec2 = (nsNotFull1(0)),  
									noc[2].ewLockedlocal = !nsNotFull(0), 
									nsShouldInc0 = (nsNotFull1(0)),  
									nsShouldDec2 = (nsNotEmpty1(2)),  
									noc[2].nsPriority = false, 
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									optimalRuns2 += ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
								=}  


				}


				else {


					tick palt {				
				

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {=  	noc[2].localPriority = true,  
									noc[2].localLockedew = !ewNotFull(3), 
									noc[2].localLen -= (ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3)),  
									ewShouldDec2 = 1,  
									noc[2].ewLockedlocal = false, 
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2)
								=} 			
						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {=   noc[2].localPriority = !(ewNotFull(3) && !nsNotFull(0)),  
									noc[2].localLockedew = !ewNotFull(3), 
									noc[2].localLen -= (ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3)),  
									ewShouldDec2 = (nsNotFull1(0)),  
									noc[2].ewLockedlocal = !nsNotFull(0), 
									nsShouldInc0 = (nsNotFull1(0)),  
									nsShouldDec2 = (nsNotEmpty1(2)),  
									noc[2].nsPriority = false, 
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									optimalRuns2 += ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
								=}  


					}
				}


		}
		

		else {
			 if (noc[2].ewLockedlocal) {

					tick palt {
						 //Local sends NS and EW sends local
						:(1/3):  tick {=  noc[2].localPriority = true,  
									noc[2].localLockedns = localNotEmpty(2) && !nsNotFull(0),  
									noc[2].localLen -= (nsNotFull1(0))*(localNotEmpty1(2)), 
									nsShouldInc0 = (nsNotFull1(0))*(localNotEmpty1(2)),  
									ewShouldDec2 = 1, 
									noc[2].ewLockedlocal = false,  
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2) 
								=} 
						// Local Sends EW and EW sends local
						:(2/3):  tick {=  noc[2].localPriority = true,  
									noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  
									ewShouldDec2 = 1,  
									noc[2].ewLockedlocal = false, 
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2) 
								=}  

					}

				}

				else if(noc[2].ewLockedns) {


						tick palt {
						//Local and EW both send to 2
						:(1/3):  {=  noc[2].localPriority = (localNotEmpty(2) && !nsNotFull(0)) || (!localNotEmpty(2) && nsNotFull(0)),  
									noc[2].localLockedns = localNotEmpty(2) && !nsNotFull(0),  
									noc[2].localLen -= (localNotEmpty1(2))*(nsNotFull1(0)),   
									nsShouldInc0 = (nsNotFull1(0)),  
									noc[2].ewLockedns = localNotEmpty(2) || (!localNotEmpty(2) && !nsNotFull(0)), 
									ewShouldDec2 = localNotEmpty0(2)*nsNotFull1(0), 
									nsShouldDec2 = (nsNotEmpty1(2)),  
									noc[2].nsPriority = false 
									//totalFlitsDelivered2 += nsNotEmpty1(2)
								=}	
								//Local has a 1 or 3 and EW has a 2
						:(2/3):  {=   noc[2].localPriority = (!ewNotFull(3) && localNotEmpty(2)) || (!localNotEmpty(2) && nsNotFull(0)) || (ewNotFull(3) && localNotEmpty(2) && nsNotFull(0)),  
									noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  
									ewShouldDec2 = (nsNotFull1(0)),  
									noc[2].ewLockedns = !nsNotFull(0), 
									nsShouldInc0 = (nsNotFull1(0)),  
									nsShouldDec2 = (nsNotEmpty1(2)),  
									noc[2].nsPriority = false, 
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									optimalRuns2 += ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
								=}  
						}


				}


				else {


					tick palt {
						//Local and EW both send to 2
						:(1/6):  {=  noc[2].localPriority = (localNotEmpty(2) && !nsNotFull(0)) || (!localNotEmpty(2) && nsNotFull(0)),  
									noc[2].localLockedns = localNotEmpty(2) && !nsNotFull(0),  
									noc[2].localLen -= (localNotEmpty1(2))*(nsNotFull1(0)),   
									nsShouldInc0 = (nsNotFull1(0)),  
									noc[2].ewLockedns = localNotEmpty(2) || (!localNotEmpty(2) && !nsNotFull(0)), 
									ewShouldDec2 = localNotEmpty0(2)*nsNotFull1(0), 
									nsShouldDec2 = (nsNotEmpty1(2)),  
									noc[2].nsPriority = false 
									//totalFlitsDelivered2 += nsNotEmpty1(2)
								=}	
						//Local Sends to 2,  EW to 0
						:(1/6):  {=  noc[2].localPriority = true,  
									noc[2].localLockedns = localNotEmpty(2) && !nsNotFull(0),  
									noc[2].localLen -= (nsNotFull1(0))*(localNotEmpty1(2)), 
									nsShouldInc0 = (nsNotFull1(0))*(localNotEmpty1(2)),  
									ewShouldDec2 = 1, 
									noc[2].ewLockedlocal = false,  
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2) 
								=}					
				

						//Local has a 1 or 3 and EW has a 0
						:(1/3):  {=  noc[2].localPriority = true,  
									noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  
									ewShouldDec2 = 1,  
									noc[2].ewLockedlocal = false, 
									//totalFlitsDelivered2 += 1, 
									noc[2].nsPriority = nsNotEmpty(2) 
								=} 			
						//Local has a 1 or 3 and EW has a 2
						:(1/3):  {=   noc[2].localPriority = (!ewNotFull(3) && localNotEmpty(2)) || (!localNotEmpty(2) && nsNotFull(0)) || (ewNotFull(3) && localNotEmpty(2) && nsNotFull(0)),  
									noc[2].localLockedew = localNotEmpty(2) && !ewNotFull(3), 
									noc[2].localLen -= (localNotEmpty1(2))*(ewNotFull1(3)),   
									ewShouldInc3 = (ewNotFull1(3))*(localNotEmpty1(2)),  
									ewShouldDec2 = (nsNotFull1(0)),  
									noc[2].ewLockedns = !nsNotFull(0), 
									nsShouldInc0 = (nsNotFull1(0)),  
									nsShouldDec2 = (nsNotEmpty1(2)),  
									noc[2].nsPriority = false, 
									//totalFlitsDelivered2 += nsNotEmpty1(2), 
									optimalRuns2 += ewNotFull1(3)*nsNotFull1(0)*nsNotEmpty1(2)
								=}  


					}
				}
		}


	}





}

process arbiter3(){

	//tick {=  localNotEmptyOne = (noc[3].localLen > 0) ? 1 : 0 =};

	if (noc[3].ewLen == 0) {		//If the EW buffer of the NoC is empty

		if (noc[3].localLockedns == true) {		//If the local buffer is locked sending NS

			tick {=  noc[3].localLockedns = !nsNotFull(1),   //Sets the priority to false if it was able to send to the ns buffer of the NoC in the y direction
				noc[3].localPriority = !nsNotFull(1) || noc[3].localPriority, 		//Local gets priority if it is unable to send
				noc[3].localLen -= nsNotFull1(1),      //Local sends a flit ns if the receiving buffer is not full
				nsShouldInc1 = (nsNotFull1(1)),   //The ns direction receives the flit if it is not already full
				nsShouldDec3 = (nsNotEmpty1(3)) 						//The ns buffer sends a flit to local if it is not empty
				//totalFlitsDelivered3 += nsNotEmpty1(3)
			=}

		}

		else if (noc[3].localLockedew) {

			tick {=   			noc[3].localLockedew = !ewNotFull(2),  // Local is locked it if has a flit and is unable to send it
							noc[3].localPriority = !ewNotFull(2) || noc[3].localPriority,   // Local gets priority under the same conditions		
							noc[3].localLen -= (ewNotFull1(2)),   //Local sends a flit to the ew direction if it is not empty and the receiving buffer is not full
							ewShouldInc2 = (ewNotFull1(2)),  //The ew direction receives it under the same conditions
							nsShouldDec3 = (nsNotEmpty1(3))  //The ns buffer sends a flit to local if it is not empty
							//totalFlitsDelivered3 += nsNotEmpty1(3)	
							
			=}


		} 

		else {
			tick palt {
				//Local sends in the NS direction
				:(1/3): {=   noc[3].localLockedns = localNotEmpty(3) && !nsNotFull(1),  // Local is locked it if has a flit and is unable to send it
							noc[3].localPriority = (localNotEmpty(3) && !nsNotFull(1)) || noc[3].localPriority,   // Local gets priority under the same conditions
							noc[3].localLen -= (localNotEmpty1(3))*(nsNotFull1(1)),   //Local sends a flit to the ns direction if it is not empty and the receiving buffer is not full
					   		nsShouldInc1 = (nsNotFull1(1))*(localNotEmpty1(3)),  //The ns direction receives the flit under the same conditions
							nsShouldDec3 = (nsNotEmpty1(3))    //The ns buffer sends a flit to local if it is not empty	
							//totalFlitsDelivered3 += nsNotEmpty1(3)
						=}
				//Local sends to the ew direction
				:(2/3): {=   noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2),  // Local is locked it if has a flit and is unable to send it
							noc[3].localPriority = (localNotEmpty(3) && !ewNotFull(2)) || noc[3].localPriority,   // Local gets priority under the same conditions
							noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   //Local sends a flit to the ew direction if it is not empty and the receiving buffer is not full
							ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  //The ew direction receives it under the same conditions
							nsShouldDec3 = (nsNotEmpty1(3))  //The ns buffer sends a flit to local if it is not empty
							//totalFlitsDelivered3 += nsNotEmpty1(3)
							
						=}
			}
		}

	}
	else if ((noc[3].localPriority == true) && (noc[3].nsPriority == true)) {

		if (noc[3].localLockedns == true) {

			if (noc[3].ewLockedns) {

				tick {=  noc[3].localLockedns = !nsNotFull(1),  	//Local stays locked if it is unable to send
					noc[3].localPriority = !nsNotFull(1), 
						noc[3].localLen -= nsNotFull1(1),   //Local sends if the ns direction is not already full
						nsShouldInc1 = nsNotFull1(1),  //The ns direction receives under the same conditions
						noc[3].nsPriority = false, 
						noc[3].ewLockedns = true,  
						nsShouldDec3 = (nsNotEmpty1(3))    //The ns buffer sends a flit to local if it is not empty 
						//totalFlitsDelivered3 += nsNotEmpty1(3)
				=}

			}

			else {
			tick palt {
			// Local and EW both send ns	
			:(1/2):  {=  noc[3].localLockedns = !nsNotFull(1),  	//Local stays locked if it is unable to send
						noc[3].localLen -= nsNotFull1(1),   //Local sends if the ns direction is not already full
						nsShouldInc1 = nsNotFull1(1),  //The ns direction receives under the same conditions
						nsShouldDec3 = (nsNotEmpty1(3)),    //The ns buffer sends a flit to local if it is not empty
						noc[3].nsPriority = false, 
						//totalFlitsDelivered3 += nsNotEmpty1(3), 
						noc[3].ewLockedns = true,  			//The Ew buffer is locked to send in the ns direction
						noc[3].localPriority = !nsNotFull(1) //Local remains in priority if it did not send
					=}  
			 
			 //Local sends ns,  and EW sends to to local
			:(1/2):  {=  noc[3].localLockedns =  !nsNotFull(1),   //Local stays locked if it is unable to send
						noc[3].localPriority = !(nsNotFull(1) && nsNotEmpty(3)),  //Local only loses priority if it sends and ew doesn't
						noc[3].localLen -= (nsNotFull1(1)),   //Local sends ns if it isn't empty and ns isn't full
						nsShouldInc1 = (nsNotFull1(1)),  //Ns receives under the same conditions
						ewShouldDec3 = nsNotEmpty0(3),  	//Ew sends if the ns buffer is empty
				
						noc[3].ewLockedlocal = nsNotEmpty(3),  	//Local is locked if the ns buffer is not empty
						noc[3].nsPriority = !nsNotEmpty(3),      //NS loses priority if it sends
						nsShouldDec3 = (nsNotEmpty1(3))  		//Ns sends local if it isn't empty
						//totalFlitsDelivered3 += nsNotEmpty1(3)
					=}    
			}
		}

		}

		else if (noc[3].localLockedew) {

			if(noc[3].ewLockedns) {	

				//Local has a 1 or 3 and EW has a 2
				tick {=  noc[3].localLockedew = !ewNotFull(2),  //Local is locked in the ew direction if it is unable to send
							noc[3].localPriority = !(!ewNotFull(2) && nsNotFull(1)),  //Local remains in priority under the same conditions
							noc[3].localLen -= (ewNotFull1(2)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc2 = (ewNotFull1(2)),  //The ew direction recieves under the same conditions
							ewShouldDec3 = (nsNotFull1(1)),   // Ew sends if the ns direction is not full
							noc[3].ewLockedns = !nsNotFull(1),  // Ew is locked to ns if it is unable to send
							nsShouldInc1 = (nsNotFull1(1)),  //The ns direction receives if it is not full
							noc[3].nsPriority = nsNotFull(1),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec3 = (nsNotEmpty1(3)),  // Ns sends if it is not empty
							//totalFlitsDelivered3 += nsNotEmpty1(3), 
							optimalRuns3 += ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)

				=} 


			}

			else {

				tick palt { 

				//Local has a 1 or 3 and EW has a 0	
				:(1/2):  {=  noc[3].localLockedew = !ewNotFull(2),  //Local is locked in the ew direction if it is unable to send
							noc[3].localPriority = !(ewNotFull(2) && nsNotEmpty(3)),  //Local remains in priority under the same conditions
							noc[3].localLen -= (ewNotFull1(2)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc2 = (ewNotFull1(2)),  //The ew direction receives under the same conditions
							noc[3].ewLockedlocal = nsNotEmpty(3),  //The ew buffer is locked into the local direction if the ns buffer is not empty
							noc[3].nsPriority = !nsNotEmpty(3),   //The ns buffer remains in priority if it is empty
							nsShouldDec3 = (nsNotEmpty1(3)), 	//Ns sneds if it is not empty
							ewShouldDec3 = nsNotEmpty0(3) 		//Ew sends if 
							//totalFlitsDelivered3 += 1
				=}	

				//Local has a 1 or 3 and EW has a 2
				:(1/2):  {=  noc[3].localLockedew = !ewNotFull(2),  //Local is locked in the ew direction if it is unable to send
							noc[3].localPriority = !(!ewNotFull(2) && nsNotFull(1)),  //Local remains in priority under the same conditions
							noc[3].localLen -= (ewNotFull1(2)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc2 = (ewNotFull1(2)),  //The ew direction recieves under the same conditions
							ewShouldDec3 = (nsNotFull1(1)),   // Ew sends if the ns direction is not full
							noc[3].ewLockedns = !nsNotFull(1),  // Ew is locked to ns if it is unable to send
							nsShouldInc1 = (nsNotFull1(1)),  //The ns direction receives if it is not full
							noc[3].nsPriority = nsNotFull(1),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec3 = (nsNotEmpty1(3)),  // Ns sends if it is not empty
							//totalFlitsDelivered3 += nsNotEmpty1(3), 
							optimalRuns3 += ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
				=} 


				}	
			}

		}

		

		else{

			if(noc[3].ewLockedns) {

				tick palt { 
				//Local and EW both send to 2	
				:(1/3): {= 	noc[3].ewLockedns = (localNotEmpty(3)) || (!localNotEmpty(3) && nsNotFull(1)),                 //The ew buffer gets locked in the ns direction if local is not empty 
							noc[3].localPriority = (localNotEmpty(3) && !nsNotFull(1)) || (!localNotEmpty(3) && nsNotFull(1)),    //Local remains in priority if it is non-empty and is unable to send
							noc[3].localLockedns = (localNotEmpty(3) && !nsNotFull(1)),  // Local gets locked to ns under the same conditions
							noc[3].localLen -= (localNotEmpty1(3))*(nsNotFull1(1)),   	//Local sends the ns direction if it is not empty,  and the receiving buffer is not full
							nsShouldInc1 = (nsNotFull1(1)),    //The ns direction receives if it is not full (either from ew or local)
							ewShouldDec3 = localNotEmpty0(3)*(nsNotFull1(1)), 		//Ew sends if local is empty and the ns direction is not full
							nsShouldDec3 = (nsNotEmpty1(3)),  		//Ns sends local if it is not empty
							noc[3].nsPriority = !localNotEmpty(3) && nsNotFull(1) 
							//totalFlitsDelivered3 += nsNotEmpty1(3)
						=}		

				//Local has a 1 or 3 and EW has a 2
				:(2/3):  {=  noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2),  //Local is locked in the ew direction if it is unable to send
							noc[3].localPriority = (localNotEmpty(3) && !ewNotFull(2)) || (!localNotEmpty(3) && nsNotFull(1)) || ( (localNotEmpty(3) && ewNotFull(2) && (nsNotFull(1)))),  //Local remains in priority under the same conditions
							noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  //The ew direction recieves under the same conditions
							ewShouldDec3 = (nsNotFull1(1)),   // Ew sends if the ns direction is not full
							noc[3].ewLockedns = !nsNotFull(1),  // Ew is locked to ns if it is unable to send
							nsShouldInc1 = (nsNotFull1(1)),  //The ns direction receives if it is not full
							noc[3].nsPriority = nsNotFull(1),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec3 = (nsNotEmpty1(3)),  // Ns sends if it is not empty
							//totalFlitsDelivered3 += nsNotEmpty1(3), 
							optimalRuns3 += localNotEmpty1(3)*ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
				=} 


				}	


			}

			else {

				tick palt { 
				//Local and EW both send to 2	
				:(1/6):  {=  noc[3].ewLockedns = (localNotEmpty(3)) || (!localNotEmpty(3) && nsNotFull(1)),                 //The ew buffer gets locked in the ns direction if local is not empty 
							noc[3].localPriority = (localNotEmpty(3) && !nsNotFull(1)) || (!localNotEmpty(3) && nsNotFull(1)),    //Local remains in priority if it is non-empty and is unable to send
							noc[3].localLockedns = (localNotEmpty(3) && !nsNotFull(1)),  // Local gets locked to ns under the same conditions
							noc[3].localLen -= (localNotEmpty1(3))*(nsNotFull1(1)),   	//Local sends the ns direction if it is not empty,  and the receiving buffer is not full
							nsShouldInc1 = (nsNotFull1(1)),    //The ns direction receives if it is not full (either from ew or local)
							ewShouldDec3 = localNotEmpty0(3)*(nsNotFull1(1)), 		//Ew sends if local is empty and the ns direction is not full
							nsShouldDec3 = (nsNotEmpty1(3)),  		//Ns sends local if it is not empty
							noc[3].nsPriority = !localNotEmpty(3) && nsNotFull(1)
							//totalFlitsDelivered3 += nsNotEmpty1(3)
						=}	

				//Local Sends to 2,  EW to 0
				:(1/6):  {=  noc[3].localLockedns = localNotEmpty(3) && !nsNotFull(1),  //Local is locked in the ns direction if it is unable to send
							noc[3].localPriority = (localNotEmpty(3) && !nsNotFull(1)) || (localNotEmpty(3) && !nsNotEmpty(3)) || ( ( (localNotEmpty(3)) && (nsNotFull(1)) ) && !nsNotEmpty(3)),  //Local remains in priority under the same conditions
							noc[3].localLen -= (localNotEmpty1(3))*(nsNotFull1(1)),   //Local sends the ns direction if it is not empty,  and the receiving buffer is not full
							nsShouldInc1 = (nsNotFull1(1))*(localNotEmpty1(3)),  //The ns direction receives if it is not full and local is not empty
							ewShouldDec3 = nsNotEmpty0(3),  //Ew sends local if the ns buffer is empty
							noc[3].ewLockedlocal = nsNotEmpty(3),  //Ew gets locked to local if the ns buffer is not empty
							noc[3].nsPriority = !nsNotEmpty(3),  //Ns remains in priority if it is empty
							nsShouldDec3 = (nsNotEmpty1(3))     // Ns sends if it is not empty
							//totalFlitsDelivered3 += 1
						=}					
				

				//Local has a 1 or 3 and EW has a 0	
				:(1/3):  {=  noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2),  //Local is locked in the ew direction if it is unable to send
							noc[3].localPriority = (localNotEmpty(3) && !ewNotFull(2)) || (localNotEmpty(3) && !nsNotEmpty(3)) || ( ( (localNotEmpty(3)) && (ewNotFull(2)) ) && !nsNotEmpty(3)),  //Local remains in priority under the same conditions
							noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  //The ew direction receives under the same conditions
							noc[3].ewLockedlocal = nsNotEmpty(3),  //The ew buffer is locked into the local direction if the ns buffer is not empty
							noc[3].nsPriority = !nsNotEmpty(3),   //The ns buffer remains in priority if it is empty
							nsShouldDec3 = (nsNotEmpty1(3)), 	//Ns sneds if it is not empty
							ewShouldDec3 = nsNotEmpty0(3) 		//Ew sends if 
							//totalFlitsDelivered3 += 1
				=}	

				//Local has a 1 or 3 and EW has a 2
				:(1/3):  {=  noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2),  //Local is locked in the ew direction if it is unable to send
							noc[3].localPriority = (localNotEmpty(3) && !ewNotFull(2)) || (!localNotEmpty(3) && nsNotFull(1)) || ( (localNotEmpty(3) && ewNotFull(2) && (nsNotFull(1)))),  //Local remains in priority under the same conditions
							noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   //Local sends ew if it is not empty and the ew direciton is not full
							ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  //The ew direction recieves under the same conditions
							ewShouldDec3 = (nsNotFull1(1)),   // Ew sends if the ns direction is not full
							noc[3].ewLockedns = !nsNotFull(1),  // Ew is locked to ns if it is unable to send
							nsShouldInc1 = (nsNotFull1(1)),  //The ns direction receives if it is not full
							noc[3].nsPriority = nsNotFull(1),   //The ns buffer stays in priority if it is empty or ew is able to send
							nsShouldDec3 = (nsNotEmpty1(3)),  // Ns sends if it is not empty
							//totalFlitsDelivered3 += nsNotEmpty1(3), 
							optimalRuns3 += localNotEmpty1(3)*ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
				=} 


				}	
			}
		}



	}

	else if ((noc[3].localPriority == false) && (noc[3].nsPriority == false)) {

			if(noc[3].localLockedns) {

							if (noc[3].ewLockedlocal) {
								tick {=  noc[3].localLockedns = !nsNotFull(1), 
									noc[3].localPriority = !nsNotFull(1), 
									noc[3].localLen -= (nsNotFull1(1)),   
									nsShouldInc1 = (nsNotFull1(1)),  
									ewShouldDec3 = 1,  
									noc[3].ewLockedlocal = false, 
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3) 
								=} 

							}

							else if (noc[3].ewLockedns) {

									tick {=  noc[3].localPriority = nsNotFull(1),  
										noc[3].localLockedns = true,  
										ewShouldDec3 = nsNotFull1(1),  
										noc[3].ewLockedns = !nsNotFull(1), 
										nsShouldInc1 = nsNotFull1(1),  
										nsShouldDec3 = (nsNotEmpty1(3)) 
										//totalFlitsDelivered3 += nsNotEmpty1(3)
									=}

							}

							else {

								tick palt{
								//Local and EW both send to 2
								:(1/2):  {=  noc[3].localPriority = nsNotFull(1),  
										noc[3].localLockedns = true,  
										ewShouldDec3 = nsNotFull1(1),  
										noc[3].ewLockedns = !nsNotFull(1), 
										nsShouldInc1 = nsNotFull1(1),  
										nsShouldDec3 = (nsNotEmpty1(3)) 
										//totalFlitsDelivered3 += nsNotEmpty1(3)
										=}			

								//Local Sends to 2,  EW to 0
								:(1/2):  {=  noc[3].localLockedns = !nsNotFull(1), 
											noc[3].localPriority = !nsNotFull(1), 
											noc[3].localLen -= (nsNotFull1(1)),   
											nsShouldInc1 = (nsNotFull1(1)),  
											ewShouldDec3 = 1,  
											//totalFlitsDelivered3 += 1, 
											noc[3].nsPriority = nsNotEmpty(3) 
										=} 				

							}

						}

			}

			else if (noc[3].localLockedew) {


					if (noc[3].ewLockedlocal) {

							// Local Sens EW and EW sends local 
							tick {=   noc[3].localLockedew = !ewNotFull(2), 
										noc[3].localPriority = !ewNotFull(2), 
										noc[3].localLen -= (ewNotFull1(2)),   
										ewShouldInc2 = (ewNotFull1(2)),  
										noc[3].ewLockedlocal = !ewNotFull(2), 
										ewShouldDec3 = 1,  
										//totalFlitsDelivered3 += 1, 
										noc[3].nsPriority = nsNotEmpty(3) 
									=}  

						

					}
					else if (noc[3].ewLockedns) {

							//Local sends EW and EW sends NS
							tick {=   noc[3].localLockedew = !ewNotFull(2), 
										noc[3].localPriority = !ewNotFull(2) && nsNotFull(1), 
										noc[3].localLen -= (ewNotFull1(2)),   
										ewShouldInc2 = (ewNotFull1(2)),  
										ewShouldDec3 = nsNotFull1(1),  
										noc[3].ewLockedns = !nsNotFull(1), 
										nsShouldInc1 = nsNotFull1(1),  
										nsShouldDec3 = (nsNotEmpty1(3)),  
										//totalFlitsDelivered3 += nsNotEmpty1(3), 
										optimalRuns3 += ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
									=} 
	

					}
					else {

						tick palt{
				
					

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {=  		noc[3].localLockedew = !ewNotFull(2), 
										noc[3].localPriority = !ewNotFull(2), 
										noc[3].localLen -= (ewNotFull1(2)),   
										ewShouldInc2 = (ewNotFull1(2)),  
										noc[3].ewLockedlocal = !ewNotFull(2), 
										ewShouldDec3 = 1,  
										//totalFlitsDelivered3 += 1, 
										noc[3].nsPriority = nsNotEmpty(3) 
								=}

						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {=  		noc[3].localLockedew = !ewNotFull(2), 
										noc[3].localPriority = !ewNotFull(2) && nsNotFull(1), 
										noc[3].localLen -= (ewNotFull1(2)),   
										ewShouldInc2 = (ewNotFull1(2)),  
										ewShouldDec3 = nsNotFull1(1),  
										noc[3].ewLockedns = !nsNotFull(1), 
										nsShouldInc1 = nsNotFull1(1),  
										nsShouldDec3 = (nsNotEmpty1(3)),  
										//totalFlitsDelivered3 += nsNotEmpty1(3), 
										optimalRuns3 += ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
						=} 

					}
			}

			


			} 

			else {

				if (noc[3].ewLockedlocal) {

					tick palt {
						
						//Local sends NS and EW sends local
						:(1/3):  {=  noc[3].localLockedns = localNotEmpty(3) && !nsNotFull(1), 
									noc[3].localPriority = localNotEmpty(3) && !nsNotFull(1), 
									noc[3].localLen -= (localNotEmpty1(3))*(nsNotFull1(1)),   
									nsShouldInc1 = (nsNotFull1(1))*(localNotEmpty1(3)),  
									ewShouldDec3 = 1,  
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3) 
								=} 

						// Local Sens EW and EW sends local 
						:(2/3):  {=   noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localPriority = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  
									ewShouldDec3 = 1,  
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3) 
								=}  

					}

				}
				else if (noc[3].ewLockedns) {

					tick palt {
						//Local sends NS and EW sends NS
						:(1/3):  {=  noc[3].localPriority =localNotEmpty(3),  
									noc[3].localLockedns = localNotEmpty(3),  
									noc[3].ewLockedns = !nsNotFull(1), 
									ewShouldDec3 = nsNotFull1(1),  
									nsShouldInc1 = nsNotFull1(1),  
									nsShouldDec3 = (nsNotEmpty1(3))  
									//totalFlitsDelivered3 += nsNotEmpty1(3)
								=}
						//Local sends EW and EW sends NS
						:(2/3):  {=   noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localPriority = localNotEmpty(3) && !ewNotFull(2) && nsNotFull(1), 
									noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  
									ewShouldDec3 = nsNotFull1(1),  
									noc[3].ewLockedns = !nsNotFull(1), 
									nsShouldInc1 = nsNotFull1(1),  
									nsShouldDec3 = (nsNotEmpty1(3)),  
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									optimalRuns3 += localNotEmpty1(3)*ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
								=} 


					}

				}
				else {

					tick palt{
					//Local and EW both send to 2
					:(1/6):  {=  		noc[3].localPriority =localNotEmpty(3),  
									noc[3].localLockedns = localNotEmpty(3),  
									noc[3].ewLockedns = !nsNotFull(1), 
									ewShouldDec3 = nsNotFull1(1),  
									nsShouldInc1 = nsNotFull1(1),  
									nsShouldDec3 = (nsNotEmpty1(3))  
									//totalFlitsDelivered3 += nsNotEmpty1(3)
							=}			

					//Local Sends to 2,  EW to 0
					:(1/6):  {=  		noc[3].localLockedns = localNotEmpty(3) && !nsNotFull(1), 
									noc[3].localPriority = localNotEmpty(3) && !nsNotFull(1), 
									noc[3].localLen -= (localNotEmpty1(3))*(nsNotFull1(1)),   
									nsShouldInc1 = (nsNotFull1(1))*(localNotEmpty1(3)),  
									ewShouldDec3 = 1,  
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3) 
							=}					
				

					//Local has a 1 or 3 and EW has a 0
					:(1/3):  {=  		noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localPriority = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  
									ewShouldDec3 = 1,  
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3) 
							=}

					//Local has a 1 or 3 and EW has a 2
					:(1/3):  {=  		noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localPriority = localNotEmpty(3) && !ewNotFull(2) && nsNotFull(1), 
									noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  
									ewShouldDec3 = nsNotFull1(1),  
									noc[3].ewLockedns = !nsNotFull(1), 
									nsShouldInc1 = nsNotFull1(1),  
									nsShouldDec3 = (nsNotEmpty1(3)),  
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									optimalRuns3 += localNotEmpty1(3)*ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
					=} 

				}
		}

		}

	}


	else if ((noc[3].localPriority == false) && (noc[3].nsPriority == true)) {

		if(noc[3].localLockedns) {

			if(noc[3].ewLockedns) {

				tick {=  noc[3].localPriority = nsNotFull(1),  
					noc[3].ewLockedns = !nsNotFull(1), 
					ewShouldDec3 = nsNotFull1(1),  
					nsShouldInc1 = nsNotFull1(1),  
					nsShouldDec3 = (nsNotEmpty1(3)), 
					//totalFlitsDelivered3 += nsNotEmpty1(3), 
					noc[3].nsPriority = nsNotFull(1)
				=} 


			}
			//Logically determined that ew cannot be locked local
			else {

			tick palt {	//Local and EW both send to 2
			:(1/2):  {=  noc[3].localPriority = nsNotFull(1),  
					noc[3].ewLockedns = !nsNotFull(1), 
					ewShouldDec3 = nsNotFull1(1),  
					nsShouldInc1 = nsNotFull1(1),  
					nsShouldDec3 = (nsNotEmpty1(3)), 
					//totalFlitsDelivered3 += nsNotEmpty1(3), 
					noc[3].nsPriority = nsNotFull(1)
					=}
					//Local Sends to 2,  EW to 0
			:(1/2):  {=  noc[3].localPriority = !nsNotFull(1), 
						noc[3].localLockedns = !nsNotFull(1), 
						noc[3].localLen -= nsNotFull1(1),   
						nsShouldInc1 = (nsNotFull1(1)),  
						ewShouldDec3 = nsNotEmpty0(3), 
						noc[3].ewLockedns = nsNotEmpty(3), 
						nsShouldDec3 = nsNotEmpty1(3),  
						//totalFlitsDelivered3 += 1, 
						noc[3].nsPriority = !nsNotEmpty(3)
				
					=}	
			}
			}



		}

		else if(noc[3].localLockedew) {

			if (noc[3].ewLockedns) {

						//Local sends EW and EW sends NS
						tick {=   noc[3].localPriority = !ewNotFull(2) && nsNotFull(1), 
									noc[3].localLockedew = !ewNotFull(2), 
									noc[3].localLen -= (ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2)),  
									noc[3].ewLockedns = !nsNotFull(1), 
									ewShouldDec3 = nsNotFull1(1),  
									nsShouldInc1 = nsNotFull1(1),  
									nsShouldDec3 = (nsNotEmpty1(3)),  
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									noc[3].nsPriority = nsNotFull(1), 
									optimalRuns3 += ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
								=} 


					

				}
			else {
				
					tick palt {				
				

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {=   noc[3].localPriority = !ewNotFull(2) && !nsNotEmpty(3),  
									noc[3].localLockedew = !ewNotFull(2), 
									noc[3].localLen -= (ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2)),  
									nsShouldDec3 = nsNotEmpty1(3), 
									noc[3].nsPriority = !nsNotEmpty(3),  
									ewShouldDec3 = nsNotEmpty0(3),  
									noc[3].ewLockedlocal = nsNotEmpty(3)
									//totalFlitsDelivered3 += 1
								=}	

						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {=  noc[3].localPriority = !ewNotFull(2) && nsNotFull(1), 
									noc[3].localLockedew = !ewNotFull(2), 
									noc[3].localLen -= (ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2)),  
									noc[3].ewLockedns = !nsNotFull(1), 
									ewShouldDec3 = nsNotFull1(1),  
									nsShouldInc1 = nsNotFull1(1),  
									nsShouldDec3 = (nsNotEmpty1(3)),  
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									noc[3].nsPriority = nsNotFull(1), 
									optimalRuns3 += ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
								=}  


					}
				}

		}


		else {
		
			 if (noc[3].ewLockedns) {

					tick palt {
						//Local sends NS and EW sends NS
						:(1/3):  tick {=  noc[3].localPriority = localNotEmpty(3) && nsNotFull(1), 
									noc[3].localLockedns = localNotEmpty(3), 
									noc[3].ewLockedns = !nsNotFull(1), 
									ewShouldDec3 = nsNotFull1(1),  
									nsShouldInc1 = nsNotFull1(1),  
									nsShouldDec3 = (nsNotEmpty1(3)), 
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									noc[3].nsPriority = nsNotFull(1)
								=} 
						//Local sends EW and EW sends NS
						:(2/3):  {=   noc[3].localPriority = localNotEmpty(3) && !ewNotFull(2) && nsNotFull(1), 
									noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  
									noc[3].ewLockedns = !nsNotFull(1), 
									ewShouldDec3 = nsNotFull1(1),  
									nsShouldInc1 = nsNotFull1(1),  
									nsShouldDec3 = (nsNotEmpty1(3)),  
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									noc[3].nsPriority = nsNotFull(1), 
									optimalRuns3 += localNotEmpty1(3)*ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
								=} 


					}

				}
			else {
				
					tick palt {
						//Local and EW both send to 2
						:(1/6):  {=  noc[3].localPriority = localNotEmpty(3) && nsNotFull(1), 
									noc[3].localLockedns = localNotEmpty(3), 
									noc[3].ewLockedns = !nsNotFull(1), 
									ewShouldDec3 = nsNotFull1(1),  
									nsShouldInc1 = nsNotFull1(1),  
									nsShouldDec3 = (nsNotEmpty1(3)), 
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									noc[3].nsPriority = nsNotFull(1)
								=}			
						//Local Sends to 2,  EW to 0
						:(1/6):  {=  noc[3].localPriority = !nsNotFull(1) && localNotEmpty(3) && !nsNotEmpty(3),  
									noc[3].localLockedns = localNotEmpty(3) && !nsNotFull(1), 
									noc[3].localLen -= (localNotEmpty1(3))*(nsNotFull1(1)),   
									nsShouldInc1 = (nsNotFull1(1))*(localNotEmpty1(3)),  
									ewShouldDec3 = nsNotEmpty0(3), 
									noc[3].ewLockedlocal = nsNotEmpty(3), 
									nsShouldDec3 = nsNotEmpty1(3),  
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = !nsNotEmpty(3) 
								=}					
				

						//Local has a 1 or 3 and EW has a 0
						:(1/3):  {=   noc[3].localPriority = !ewNotFull(2) && localNotEmpty(3) && !nsNotEmpty(3),  
									noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  
									nsShouldDec3 = nsNotEmpty1(3), 
									noc[3].nsPriority = !nsNotEmpty(3),  
									ewShouldDec3 = nsNotEmpty0(3), 
									noc[3].ewLockedlocal = nsNotEmpty(3) 
									//totalFlitsDelivered3 += 1
								=}	

						//Local has a 1 or 3 and EW has a 2
						:(1/3):  {=  noc[3].localPriority = localNotEmpty(3) && !ewNotFull(2) && nsNotFull(1), 
									noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  
									noc[3].ewLockedns = !nsNotFull(1), 
									ewShouldDec3 = nsNotFull1(1),  
									nsShouldInc1 = nsNotFull1(1),  
									nsShouldDec3 = (nsNotEmpty1(3)),  
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									noc[3].nsPriority = nsNotFull(1), 
									optimalRuns3 += localNotEmpty1(3)*ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
								=}  


					}
				}

		}

	}
	else {   //Localpriority == true && nsPriority == false

		if(noc[3].localLockedns) {

			if (noc[3].ewLockedlocal) {


						 //Local sends NS and EW sends local
								tick {=  noc[3].localPriority = true,  
									noc[3].localLockedns = !nsNotFull(1),  
									noc[3].localLen -= (nsNotFull1(1)), 
									nsShouldInc1 = (nsNotFull1(1)),  
									ewShouldDec3 = 1,  
									noc[3].ewLockedlocal = false, 
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3) 
								=} 

				}

				else if(noc[3].ewLockedns) {

							tick {=  noc[3].localPriority = !nsNotFull(1),  
									noc[3].localLockedns = !nsNotFull(1),  
									noc[3].localLen -= (nsNotFull1(1)),   
									nsShouldInc1 = (nsNotFull1(1)),  
									noc[3].ewLockedns = true, 
									nsShouldDec3 = (nsNotEmpty1(3)),  
									noc[3].nsPriority = false 
									//totalFlitsDelivered3 += nsNotEmpty1(3)
								=}	


				}


				else {


					tick palt {
						//Local and EW both send to 2
						:(1/2):  {=  	noc[3].localPriority = !nsNotFull(1),  
									noc[3].localLockedns = !nsNotFull(1),  
									noc[3].localLen -= (nsNotFull1(1)),   
									nsShouldInc1 = (nsNotFull1(1)),  
									noc[3].ewLockedns = true, 
									nsShouldDec3 = (nsNotEmpty1(3)),  
									noc[3].nsPriority = false 
									//totalFlitsDelivered3 += nsNotEmpty1(3)
								=}	
						//Local Sends to 2,  EW to 0
						:(1/2):  {=  noc[3].localPriority = true,  
									noc[3].localLockedns = !nsNotFull(1),  
									noc[3].localLen -= (nsNotFull1(1)), 
									nsShouldInc1 = (nsNotFull1(1)),  
									ewShouldDec3 = 1,  
									noc[3].ewLockedlocal = false, 
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3) 
								=}					


					}
				}

		}

		else if(noc[3].localLockedew) {

			if (noc[3].ewLockedlocal) {

						// Local Sends EW and EW sends local
					tick {=  	noc[3].localPriority = true,  
						noc[3].localLockedew = !ewNotFull(2), 
						noc[3].localLen -= (ewNotFull1(2)),   
						ewShouldInc2 = (ewNotFull1(2)),  
						ewShouldDec3 = 1,  
						noc[3].ewLockedlocal = false, 
						//totalFlitsDelivered3 += 1, 
						noc[3].nsPriority = nsNotEmpty(3) 
					=}  

					

				}

				else if(noc[3].ewLockedns) {

	
								//Local has a 1 or 3 and EW has a 2
						tick {=   		noc[3].localPriority = !(ewNotFull(2) && !nsNotFull(1)),  
									noc[3].localLockedew = !ewNotFull(2), 
									noc[3].localLen -= (ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2)),  
									ewShouldDec3 = (nsNotFull1(1)),  
									noc[3].ewLockedlocal = !nsNotFull(1), 
									nsShouldInc1 = (nsNotFull1(1)),  
									nsShouldDec3 = (nsNotEmpty1(3)),  
									noc[3].nsPriority = false, 
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									optimalRuns3 += ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
								=}  


				}


				else {


					tick palt {				
				

						//Local has a 1 or 3 and EW has a 0
						:(1/2):  {=  	noc[3].localPriority = true,  
									noc[3].localLockedew = !ewNotFull(2), 
									noc[3].localLen -= (ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2)),  
									ewShouldDec3 = 1,  
									noc[3].ewLockedlocal = false, 
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3)
								=} 			
						//Local has a 1 or 3 and EW has a 2
						:(1/2):  {=   noc[3].localPriority = !(ewNotFull(2) && !nsNotFull(1)),  
									noc[3].localLockedew = !ewNotFull(2), 
									noc[3].localLen -= (ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2)),  
									ewShouldDec3 = (nsNotFull1(1)),  
									noc[3].ewLockedlocal = !nsNotFull(1), 
									nsShouldInc1 = (nsNotFull1(1)),  
									nsShouldDec3 = (nsNotEmpty1(3)),  
									noc[3].nsPriority = false, 
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									optimalRuns3 += ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
								=}  


					}
				}


		}
		

		else {
			 if (noc[3].ewLockedlocal) {

					tick palt {
						 //Local sends NS and EW sends local
						:(1/3):  tick {=  noc[3].localPriority = true,  
									noc[3].localLockedns = localNotEmpty(3) && !nsNotFull(1),  
									noc[3].localLen -= (nsNotFull1(1))*(localNotEmpty1(3)), 
									nsShouldInc1 = (nsNotFull1(1))*(localNotEmpty1(3)),  
									ewShouldDec3 = 1, 
									noc[3].ewLockedlocal = false,  
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3) 
								=} 
						// Local Sends EW and EW sends local
						:(2/3):  tick {=  noc[3].localPriority = true,  
									noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  
									ewShouldDec3 = 1,  
									noc[3].ewLockedlocal = false, 
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3) 
								=}  

					}

				}

				else if(noc[3].ewLockedns) {


						tick palt {
						//Local and EW both send to 2
						:(1/3):  {=  noc[3].localPriority = (localNotEmpty(3) && !nsNotFull(1)) || (!localNotEmpty(3) && nsNotFull(1)),  
									noc[3].localLockedns = localNotEmpty(3) && !nsNotFull(1),  
									noc[3].localLen -= (localNotEmpty1(3))*(nsNotFull1(1)),   
									nsShouldInc1 = (nsNotFull1(1)),  
									noc[3].ewLockedns = localNotEmpty(3) || (!localNotEmpty(3) && !nsNotFull(1)), 
									ewShouldDec3 = localNotEmpty0(3)*nsNotFull1(1), 
									nsShouldDec3 = (nsNotEmpty1(3)),  
									noc[3].nsPriority = false 
									//totalFlitsDelivered3 += nsNotEmpty1(3)
								=}	
								//Local has a 1 or 3 and EW has a 2
						:(2/3):  {=   noc[3].localPriority = (!ewNotFull(2) && localNotEmpty(3)) || (!localNotEmpty(3) && nsNotFull(1)) || (ewNotFull(2) && localNotEmpty(3) && nsNotFull(1)),  
									noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  
									ewShouldDec3 = (nsNotFull1(1)),  
									noc[3].ewLockedns = !nsNotFull(1), 
									nsShouldInc1 = (nsNotFull1(1)),  
									nsShouldDec3 = (nsNotEmpty1(3)),  
									noc[3].nsPriority = false, 
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									optimalRuns3 += ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
								=}  
						}


				}


				else {


					tick palt {
						//Local and EW both send to 2
						:(1/6):  {=  noc[3].localPriority = (localNotEmpty(3) && !nsNotFull(1)) || (!localNotEmpty(3) && nsNotFull(1)),  
									noc[3].localLockedns = localNotEmpty(3) && !nsNotFull(1),  
									noc[3].localLen -= (localNotEmpty1(3))*(nsNotFull1(1)),   
									nsShouldInc1 = (nsNotFull1(1)),  
									noc[3].ewLockedns = localNotEmpty(3) || (!localNotEmpty(3) && !nsNotFull(1)), 
									ewShouldDec3 = localNotEmpty0(3)*nsNotFull1(1), 
									nsShouldDec3 = (nsNotEmpty1(3)),  
									noc[3].nsPriority = false 
									//totalFlitsDelivered3 += nsNotEmpty1(3)
								=}	
						//Local Sends to 2,  EW to 0
						:(1/6):  {=  noc[3].localPriority = true,  
									noc[3].localLockedns = localNotEmpty(3) && !nsNotFull(1),  
									noc[3].localLen -= (nsNotFull1(1))*(localNotEmpty1(3)), 
									nsShouldInc1 = (nsNotFull1(1))*(localNotEmpty1(3)),  
									ewShouldDec3 = 1, 
									noc[3].ewLockedlocal = false,  
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3) 
								=}					
				

						//Local has a 1 or 3 and EW has a 0
						:(1/3):  {=  noc[3].localPriority = true,  
									noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  
									ewShouldDec3 = 1,  
									noc[3].ewLockedlocal = false, 
									//totalFlitsDelivered3 += 1, 
									noc[3].nsPriority = nsNotEmpty(3) 
								=} 			
						//Local has a 1 or 3 and EW has a 2
						:(1/3):  {=   noc[3].localPriority = (!ewNotFull(2) && localNotEmpty(3)) || (!localNotEmpty(3) && nsNotFull(1)) || (ewNotFull(2) && localNotEmpty(3) && nsNotFull(1)),  
									noc[3].localLockedew = localNotEmpty(3) && !ewNotFull(2), 
									noc[3].localLen -= (localNotEmpty1(3))*(ewNotFull1(2)),   
									ewShouldInc2 = (ewNotFull1(2))*(localNotEmpty1(3)),  
									ewShouldDec3 = (nsNotFull1(1)),  
									noc[3].ewLockedns = !nsNotFull(1), 
									nsShouldInc1 = (nsNotFull1(1)),  
									nsShouldDec3 = (nsNotEmpty1(3)),  
									noc[3].nsPriority = false, 
									//totalFlitsDelivered3 += nsNotEmpty1(3), 
									optimalRuns3 += ewNotFull1(2)*nsNotFull1(1)*nsNotEmpty1(3)
								=}  


					}
				}
		}


	}





}







par{
:: 	Top()
::  Arbiter0()
::  Arbiter1()
::  Arbiter2()
::  Arbiter3() 
}
