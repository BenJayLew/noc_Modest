/*
NoC router IDs
	0 - 1
	|   |
	2 - 3
*/

option "dtmc";

//Top level varables
const int BUFFERLENGTH = 3; //Each buffer actually has length of BUFFERLENGTH + 1 because one directionue is stored in the arbiter itself for easy use when routing.
const int NOCSIZE = 2;
const int INJECTIONRATENUMERATOR = 1;
const int INJECTIONRATEDENOMINATOR = 2;

const int DUR;
const int clkLower = 100; 
const int clkUpper = clkLower + DUR;
int(clkLower..clkUpper) clk;
//transient int(0..1) clk;

datatype intlist = { int(0.. ((NOCSIZE*NOCSIZE)-1)) hd, intlist option tl };

datatype channel = {int(-1..4) direction, int(0..4) id, bool serviced, int(0..4) priority, intlist option buff};		//Datatype for a channel with the next buffer directionue, id of the buffer, whether the buffer was serviced last clock cycle or not, and the priority number of the buffer

datatype router = {int(0..3) unserviced, int(0..3) totalUnserviced, channel[] channelArray, channel[] temp, int[]bufferID};	//Datatype for a router, includes router-specific variables and an array of buffers

int(0..4) optimalRunsIncrement = 0;

int(0..5) optimalRuns;

int test = 0;

router[] noc = [router {unserviced:0}, router {unserviced:0}, router {unserviced:0}, router {unserviced:0}];

action tick;


// ------ Begin: properties ---------
property Pr1 = Pmax(<> (optimalRuns >= 1));
//property p1 = Pmax(<>[S(clk)<=(clkUpper-clkLower)] (optimalRuns >= 1));
//property optimalRuns = Pmax(<> (optimalRuns >= OPTIMALRUNSMEASURE));
// ------ End: properties ---------



// ------ Begin: function definitions ------- 
// Calculate length of list:
function int len(intlist option ls) = if ls == none then 0 else 1 + len(ls!.tl); // "!" accesses the directionue of a non-empty option (causes an error if the option is empty)

// Return the front of the queue, i.e., the last element of the given integer list. No changes are made to the list.
function int peekFront(intlist option ls) =
	 if ls == none then -1
	 else if ls!.tl == none then ls!.hd
	      else peekFront(ls!.tl);

//Remove the front of the queue, i.e., the last element of the given integer list. Return the modified list. 
function intlist option dequeue(intlist option ls) = 
	if ls == none then none
	else if	ls!.tl == none then none 
		 else some(intlist { hd: ls!.hd, tl: dequeue(ls!.tl) });	

//Insert a new entry n as the head of the list ls. If ls has already reached its capacity before adding n, return ls; otherwise, return modified ls with n as its head. 
function intlist option enqueue(int n, intlist option ls) = 
	if len(ls) == BUFFERLENGTH then ls
	else some(intlist { hd: n, tl: ls });		 

//Routing function	(x-y routing)
/*
function int route(int dest, int routerID) =
	if dest == -1 then -1//no flit
	else if (dest % NOCSIZE) > (routerID % NOCSIZE) then 1//east
	else if (dest % NOCSIZE) < (routerID % NOCSIZE) then 3//west
	else if (dest / NOCSIZE) > (routerID / NOCSIZE) then 2//south
	else if (dest / NOCSIZE) < (routerID / NOCSIZE) then 0//north
	else 4//local
	;
*/
function int route(int dest, int routerID) =
	if dest == -1 then -1//no flit
	else if (dest == routerID) then 4//local
	else if (dest == routerID + 1) then 1//east
	else if (dest == routerID - 1) then 3//west
	else if (dest == routerID + NOCSIZE) then 2//south
	else if (dest == routerID - NOCSIZE) then 0//north
	else 4//local
	;

// ------ Begin: process definitions ------
//---- Paralell Processes ----
process Clock(){	
	//tick {= clk=1 =};
	//Clock()	

	
	tick {= 
		clk++,
		optimalRuns += optimalRunsIncrement
	=};
	if (clk <= clkUpper) {
	   Clock()
	}
	else {
	   stop
	} 
		
}

process Top(){
	initialize();
	Populate();
	initialRoute(0);
	initialRoute(1);
	initialRoute(2);
	initialRoute(3);
	do{
		Arbiter_corner(0);
		Arbiter_corner(1);
		Arbiter_corner(2);
		Arbiter_corner(3);	
		
		tick;
		
		Populate();	
		
		updateDestination(0, 0);
		updateDestination(1, 0);
		updateDestination(2, 0);
		
		updateDestination(0, 1);
		updateDestination(1, 1);
		updateDestination(2, 1);
		
		updateDestination(0, 2);
		updateDestination(1, 2);
		updateDestination(2, 2);
		
		updateDestination(0, 3);
		updateDestination(1, 3);
		updateDestination(2, 3);

		
		if(clk>=clkUpper){
			stop
		}
		else{
			tau
		} 
		
	}
}

process Populate(){

	if((clk % INJECTIONRATEDENOMINATOR) < INJECTIONRATENUMERATOR){
		{= test++ =};
		subPopulate(0);
		subPopulate(1);
		subPopulate(2);
		subPopulate(3)
	}
	else {tau}
}


//---- Sub processes ----
process Arbiter_corner(int routerID){
	//Service buffers-------------------------------------------------------------------------------------------------------
		
		//Buffer priority 0
		//<Service Buffer channelArray[0]>--------------------------------------------------------
		if((noc[routerID].channelArray[0].direction == -1) ||  
			(noc[routerID].channelArray[0].direction == 4) || 
			((noc[routerID].channelArray[0].direction == 0) && (len(noc[routerID - NOCSIZE].channelArray[noc[routerID - NOCSIZE].bufferID[2]].buff) < BUFFERLENGTH)) || 
			((noc[routerID].channelArray[0].direction == 1) && (len(noc[routerID + 1].channelArray[noc[routerID + 1].bufferID[3]].buff) < BUFFERLENGTH)) ||
			((noc[routerID].channelArray[0].direction == 2) && (len(noc[routerID + NOCSIZE].channelArray[noc[routerID + NOCSIZE].bufferID[0]].buff) < BUFFERLENGTH)) ||
			((noc[routerID].channelArray[0].direction == 3) && (len(noc[routerID - 1].channelArray[noc[routerID - 1].bufferID[1]].buff) < BUFFERLENGTH))){
			{= 
			noc[routerID].channelArray[0].serviced = true
			=}
		}
		else{
			{= 
			noc[routerID].channelArray[0].serviced = false,
			noc[routerID].totalUnserviced++,
			noc[routerID].unserviced++ 		//Increment unserviced
			=}
		};
		
		//<Service buffer <channelArray[1]> ------------------------------------------------------
		if((noc[routerID].channelArray[1].direction == -1) || ((noc[routerID].channelArray[1].direction != noc[routerID].channelArray[0].direction) &&
			(noc[routerID].channelArray[1].direction == 4) ||
			(noc[routerID].channelArray[1].direction == 0 && len(noc[routerID - NOCSIZE].channelArray[noc[routerID - NOCSIZE].bufferID[2]].buff) < BUFFERLENGTH) || 
			(noc[routerID].channelArray[1].direction == 1 && len(noc[routerID + 1].channelArray[noc[routerID + 1].bufferID[3]].buff) < BUFFERLENGTH) ||
			(noc[routerID].channelArray[1].direction == 2 && len(noc[routerID + NOCSIZE].channelArray[noc[routerID + NOCSIZE].bufferID[0]].buff) < BUFFERLENGTH) ||
			(noc[routerID].channelArray[1].direction == 3 && len(noc[routerID - 1].channelArray[noc[routerID - 1].bufferID[1]].buff) < BUFFERLENGTH))
			) {			//If buffer channelArray[1] conflicts with channelArray[0]
			{= 	//Service Buffer
			noc[routerID].channelArray[1].serviced = true
			=}
		}
		else {
			{= 
			noc[routerID].channelArray[1].serviced = false,
			noc[routerID].totalUnserviced++,
			noc[routerID].unserviced++ 		//Increment unserviced
			=}
		};
		
		//<Service buffer channelArray[2]> --------------------------------------------------------
		//If buffer channelArray[2] conflicts with channelArray[1] or channelArray[0]
		if((noc[routerID].channelArray[2].direction == -1) || ((noc[routerID].channelArray[2].direction != noc[routerID].channelArray[1].direction && noc[routerID].channelArray[2].direction != noc[routerID].channelArray[0].direction) &&
			(noc[routerID].channelArray[2].direction == 4) ||
			(noc[routerID].channelArray[2].direction == 0 && len(noc[routerID - NOCSIZE].channelArray[noc[routerID - NOCSIZE].bufferID[2]].buff) < BUFFERLENGTH) || 
			(noc[routerID].channelArray[2].direction == 1 && len(noc[routerID + 1].channelArray[noc[routerID + 1].bufferID[3]].buff) < BUFFERLENGTH) ||
			(noc[routerID].channelArray[2].direction == 2 && len(noc[routerID + NOCSIZE].channelArray[noc[routerID + NOCSIZE].bufferID[0]].buff) < BUFFERLENGTH) ||
			(noc[routerID].channelArray[2].direction == 3 && len(noc[routerID - 1].channelArray[noc[routerID - 1].bufferID[1]].buff) < BUFFERLENGTH))
		){	
			{= 		//Service Buffer
			noc[routerID].channelArray[2].serviced = true
			=}
		}
		else {
			{= 
			noc[routerID].channelArray[2].serviced = false, 
			noc[routerID].totalUnserviced++,
			noc[routerID].unserviced++			//Increment unserviced
			=}
		};
		
		
		//Increment optimal runs if there were no conflitcs -------------------------------------------------------------------
		if(noc[routerID].unserviced == 0 && noc[routerID].channelArray[0].direction != -1 && noc[routerID].channelArray[1].direction != -1 && noc[routerID].channelArray[2].direction != -1){
			{= 
				optimalRunsIncrement++
			=}
		}
		
		else{tau};
		
		//Set priority directionues for the next run and update the directionue of the buffers----------------------------------------------
		setPriority(0, routerID);
		setPriority(1, routerID);
		setPriority(2, routerID);
		
		//need to update the bufferID array
		//test update for router 0
		
		if(routerID == 0){
			{=
				noc[routerID].bufferID[1] = noc[routerID].channelArray[noc[routerID].bufferID[1]].priority,
				noc[routerID].bufferID[2] = noc[routerID].channelArray[noc[routerID].bufferID[2]].priority,
				noc[routerID].bufferID[4] = noc[routerID].channelArray[noc[routerID].bufferID[4]].priority
			=}
		}
		else if(routerID == 1){
			{=
				noc[routerID].bufferID[2] = noc[routerID].channelArray[noc[routerID].bufferID[2]].priority,
				noc[routerID].bufferID[3] = noc[routerID].channelArray[noc[routerID].bufferID[3]].priority,
				noc[routerID].bufferID[4] = noc[routerID].channelArray[noc[routerID].bufferID[4]].priority
			=}
		}
		else if(routerID == 2){
			{=
				noc[routerID].bufferID[0] = noc[routerID].channelArray[noc[routerID].bufferID[0]].priority,
				noc[routerID].bufferID[1] = noc[routerID].channelArray[noc[routerID].bufferID[1]].priority,
				noc[routerID].bufferID[4] = noc[routerID].channelArray[noc[routerID].bufferID[4]].priority
			=}
		}
		else if(routerID == 3){
			{=
				noc[routerID].bufferID[0] = noc[routerID].channelArray[noc[routerID].bufferID[0]].priority,
				noc[routerID].bufferID[3] = noc[routerID].channelArray[noc[routerID].bufferID[3]].priority,
				noc[routerID].bufferID[4] = noc[routerID].channelArray[noc[routerID].bufferID[4]].priority
			=}
		}
		else{tau};
		
		
		//Rewrite buffer array with new priority directionues-------------------------------------------------------------------------
		{= 
		noc[routerID].temp[noc[routerID].channelArray[0].priority] = noc[routerID].channelArray[0],
		noc[routerID].temp[noc[routerID].channelArray[1].priority] = noc[routerID].channelArray[1],
		noc[routerID].temp[noc[routerID].channelArray[2].priority] = noc[routerID].channelArray[2],
		
		noc[routerID].bufferID[noc[routerID].channelArray[0].id] = noc[routerID].channelArray[0].priority,
		noc[routerID].bufferID[noc[routerID].channelArray[1].id] = noc[routerID].channelArray[1].priority,
		noc[routerID].bufferID[noc[routerID].channelArray[2].id] = noc[routerID].channelArray[2].priority
		=};
		
		{= noc[routerID].channelArray = noc[routerID].temp =}
}
	
//initialize directionues --------------------------------------------------------------------------------------------------------------------------------------------
process initialize(){
	initialize_node_nw(0);
	initialize_node_ne(1);
	initialize_node_sw(2);
	initialize_node_se(3)
}

process initialize_node_nw(int routerID){
	channel east, south, local;
	{=
	noc[routerID].channelArray = [east, south, local],
	noc[routerID].temp = [east, south, local],
	
	noc[routerID].bufferID = [-1, 0, 1, -1, 2],
	
	noc[routerID].channelArray[0].id = 1, 
	noc[routerID].channelArray[1].id = 2, 
	noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0
	
	=}
}

process initialize_node_ne(int routerID){
	channel south, west, local;
	{=
	noc[routerID].channelArray = [south, west, local],
	noc[routerID].temp = [south, west, local], 
	
	noc[routerID].bufferID = [-1, -1, 0, 1, 2],
	
	noc[routerID].channelArray[0].id = 2, 
	noc[routerID].channelArray[1].id = 3, 
	noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0
	=}
}

process initialize_node_sw(int routerID){
	channel north, east, local;
	{=
	noc[routerID].channelArray = [north, east, local],
	noc[routerID].temp = [north, east, local], 
	
	noc[routerID].bufferID = [0, 1, -1, -1, 2],
	
	noc[routerID].channelArray[0].id = 0, 
	noc[routerID].channelArray[1].id = 1, 
	noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0
	=}
}

process initialize_node_se(int routerID){
	channel north, west, local;
	{=
	noc[routerID].channelArray = [north, west, local],
	noc[routerID].temp = [north, west, local], 
	
	noc[routerID].bufferID = [0, -1, -1, 1, 2],
	
	noc[routerID].channelArray[0].id = 0, 
	noc[routerID].channelArray[1].id = 3, 
	noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0
	=}
	
}

//runs routing after initial setup (for testing)
process initialRoute(int routerID){
	{=
	noc[routerID].channelArray[0].direction = route(peekFront(noc[routerID].channelArray[0].buff), routerID),
	noc[routerID].channelArray[1].direction = route(peekFront(noc[routerID].channelArray[1].buff), routerID),
	noc[routerID].channelArray[2].direction = route(peekFront(noc[routerID].channelArray[2].buff), routerID)
	=}
}


//Sets the new priority directionue of buffer channelArray[i] and forwards the detination if the buffer was serviced ------------------------------------------------------------------
process setPriority(int i, int routerID){
	if (noc[routerID].channelArray[i].serviced == true){
		if(noc[routerID].channelArray[i].direction == -1){ tau }
		else if(noc[routerID].channelArray[i].direction == 4){			//Send in the local direction
			
			{= 
			noc[routerID].channelArray[i].direction = -1,
			noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff)			
			=}			//flit delivered
		}
		else if(noc[routerID].channelArray[i].direction == 0){			//Send in the north direction
			{=
			noc[routerID - NOCSIZE].channelArray[noc[routerID - NOCSIZE].bufferID[2]].buff = enqueue(peekFront(noc[routerID].channelArray[i].buff), noc[routerID - NOCSIZE].channelArray[noc[routerID - NOCSIZE].bufferID[2]].buff),
			noc[routerID].channelArray[i].direction = -1,
			noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff)
			=}
		}
		else if(noc[routerID].channelArray[i].direction == 1){			//Send in the east direction
			{=
			noc[routerID + 1].channelArray[noc[routerID + 1].bufferID[3]].buff = enqueue(peekFront(noc[routerID].channelArray[i].buff), noc[routerID + 1].channelArray[noc[routerID + 1].bufferID[3]].buff),
			noc[routerID].channelArray[i].direction = -1,
			noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff)
			=}
		}
		else if(noc[routerID].channelArray[i].direction == 2){			//Send in the south direction
			{=
			noc[routerID + NOCSIZE].channelArray[noc[routerID + NOCSIZE].bufferID[0]].buff = enqueue(peekFront(noc[routerID].channelArray[i].buff), noc[routerID + NOCSIZE].channelArray[noc[routerID + NOCSIZE].bufferID[0]].buff),
			noc[routerID].channelArray[i].direction = -1,
			noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff)
			=}
		}
		else if(noc[routerID].channelArray[i].direction == 3){			//Send in the west direction
			{=
			noc[routerID - 1].channelArray[noc[routerID - 1].bufferID[1]].buff = enqueue(peekFront(noc[routerID].channelArray[i].buff), noc[routerID - 1].channelArray[noc[routerID - 1].bufferID[1]].buff),
			noc[routerID].channelArray[i].direction = -1,
			noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff)
			=}
		}
		else {tau};
		
		{=
		noc[routerID].channelArray[i].priority = i + noc[routerID].unserviced 				//Set new priority
		=}
	}
	else {
		{= 
		noc[routerID].channelArray[i].priority = noc[routerID].totalUnserviced - noc[routerID].unserviced,		//Set new priority
		noc[routerID].unserviced-- 						//decrement unserviced
		=}
	}
}

//Updates the destination from the buffer if the buffer was serviced
process updateDestination(int i , int routerID){
	if(noc[routerID].channelArray[i].serviced == true){
		//{= 
		//noc[routerID].channelArray[i].dest = peekFront(noc[routerID].channelArray[i].buff)
		//=};
		{=
		noc[routerID].channelArray[i].direction = route(peekFront(noc[routerID].channelArray[i].buff), routerID)		//Update directionue from buffer
		//noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff)
		=}
	}
	else {tau}
}

//Populate the buffers with new directionues
process subPopulate(int routerID){
	{= noc[routerID].channelArray[noc[routerID].bufferID[4]].buff = enqueue(((DiscreteUniform(1, 3) + routerID) % 4), noc[routerID].channelArray[noc[routerID].bufferID[4]].buff) =}
}
// ------- End: process definitions -------

par{
::	Clock()
:: 	Top()
}
